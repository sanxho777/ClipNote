{"version":3,"file":"content.js","mappings":"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","sources":["webpack://workspace/webpack/runtime/chunk loaded","webpack://workspace/./src/core/selectors.ts","webpack://workspace/./src/core/photos.ts","webpack://workspace/./src/adapters/autotrader.ts","webpack://workspace/./src/adapters/cars_dot_com.ts","webpack://workspace/./src/adapters/cargurus.ts","webpack://workspace/./src/adapters/dealer_dot_com.ts","webpack://workspace/./src/adapters/generic.ts","webpack://workspace/./src/core/scrape.ts","webpack://workspace/./src/core/facebook.ts","webpack://workspace/./src/content.ts","webpack://workspace/webpack/bootstrap","webpack://workspace/webpack/runtime/define property getters","webpack://workspace/webpack/runtime/hasOwnProperty shorthand","webpack://workspace/webpack/runtime/jsonp chunk loading","webpack://workspace/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","import { Logger } from './logger';\n\nexport class SelectorProbe {\n  private logger = new Logger('SelectorProbe');\n\n  /**\n   * Find element using multiple selectors (first match wins)\n   */\n  findElement(selectors: string[]): Element | null {\n    for (const selector of selectors) {\n      try {\n        const element = document.querySelector(selector);\n        if (element) {\n          this.logger.debug(`Found element with selector: ${selector}`);\n          return element;\n        }\n      } catch (error) {\n        this.logger.warn(`Invalid selector: ${selector}`, error);\n      }\n    }\n    \n    this.logger.debug(`No element found with selectors: ${selectors.join(', ')}`);\n    return null;\n  }\n\n  /**\n   * Find all elements using multiple selectors\n   */\n  findElements(selectors: string[]): Element[] {\n    const elements: Element[] = [];\n    \n    for (const selector of selectors) {\n      try {\n        const found = document.querySelectorAll(selector);\n        elements.push(...Array.from(found));\n      } catch (error) {\n        this.logger.warn(`Invalid selector: ${selector}`, error);\n      }\n    }\n    \n    // Remove duplicates\n    const unique = Array.from(new Set(elements));\n    this.logger.debug(`Found ${unique.length} unique elements`);\n    return unique;\n  }\n\n  /**\n   * Find element by label proximity (looks for labels near form elements)\n   */\n  findByLabel(labels: string[], container?: Element): Element | null {\n    const searchContainer = container || document;\n    \n    for (const label of labels) {\n      // Try direct label association first\n      const labelElement = this.findLabelElement(label, searchContainer as Element);\n      if (labelElement) {\n        const associated = this.getAssociatedElement(labelElement);\n        if (associated) {\n          this.logger.debug(`Found element by label association: ${label}`);\n          return associated;\n        }\n      }\n      \n      // Try proximity-based search\n      const proximityElement = this.findByProximity(label, searchContainer as Element);\n      if (proximityElement) {\n        this.logger.debug(`Found element by proximity: ${label}`);\n        return proximityElement;\n      }\n    }\n    \n    this.logger.debug(`No element found by labels: ${labels.join(', ')}`);\n    return null;\n  }\n\n  /**\n   * Find element by text content proximity\n   */\n  findByProximity(searchText: string, container: Element | Document = document): Element | null {\n    const searchLower = searchText.toLowerCase();\n    \n    // Find all text nodes containing the search text\n    const textNodes = this.findTextNodes(container as Element, searchLower);\n    \n    for (const textNode of textNodes) {\n      const parentElement = textNode.parentElement;\n      if (!parentElement) continue;\n      \n      // Look for form elements near this text\n      const nearbyElements = this.findNearbyFormElements(parentElement);\n      \n      for (const element of nearbyElements) {\n        if (this.isRelevantFormElement(element)) {\n          this.logger.debug(`Found element by proximity to text: ${searchText}`);\n          return element;\n        }\n      }\n    }\n    \n    return null;\n  }\n\n  /**\n   * Find elements by ARIA attributes\n   */\n  findByAria(ariaLabels: string[]): Element | null {\n    for (const label of ariaLabels) {\n      // Try aria-label\n      let element = document.querySelector(`[aria-label*=\"${label}\" i]`);\n      if (element) {\n        this.logger.debug(`Found element by aria-label: ${label}`);\n        return element;\n      }\n      \n      // Try aria-labelledby\n      const labelElement = document.querySelector(`[aria-labelledby*=\"${label}\" i]`);\n      if (labelElement) {\n        this.logger.debug(`Found element by aria-labelledby: ${label}`);\n        return labelElement;\n      }\n      \n      // Try aria-describedby\n      element = document.querySelector(`[aria-describedby*=\"${label}\" i]`);\n      if (element) {\n        this.logger.debug(`Found element by aria-describedby: ${label}`);\n        return element;\n      }\n    }\n    \n    return null;\n  }\n\n  /**\n   * Wait for element to appear\n   */\n  async waitForElement(selectors: string[], timeout = 10000): Promise<Element | null> {\n    const startTime = Date.now();\n    \n    while (Date.now() - startTime < timeout) {\n      const element = this.findElement(selectors);\n      if (element) {\n        return element;\n      }\n      \n      await new Promise(resolve => setTimeout(resolve, 100));\n    }\n    \n    this.logger.warn(`Timeout waiting for element: ${selectors.join(', ')}`);\n    return null;\n  }\n\n  /**\n   * Check if element is visible\n   */\n  isVisible(element: Element): boolean {\n    const rect = element.getBoundingClientRect();\n    const style = getComputedStyle(element);\n    \n    return (\n      rect.width > 0 &&\n      rect.height > 0 &&\n      style.visibility !== 'hidden' &&\n      style.display !== 'none' &&\n      style.opacity !== '0'\n    );\n  }\n\n  /**\n   * Get element's computed style properties\n   */\n  getElementInfo(element: Element): object {\n    const rect = element.getBoundingClientRect();\n    const style = getComputedStyle(element);\n    \n    return {\n      tagName: element.tagName,\n      id: element.id,\n      className: element.className,\n      textContent: element.textContent?.slice(0, 100),\n      visible: this.isVisible(element),\n      position: {\n        x: rect.x,\n        y: rect.y,\n        width: rect.width,\n        height: rect.height\n      },\n      style: {\n        display: style.display,\n        visibility: style.visibility,\n        opacity: style.opacity\n      }\n    };\n  }\n\n  /**\n   * Find label element by text content\n   */\n  private findLabelElement(labelText: string, container: Element): Element | null {\n    // Build selector patterns for manual search\n    \n    // Since :contains() is not standard, we'll search manually\n    const labels = container.querySelectorAll('label, .label, [data-label]');\n    \n    for (const label of labels) {\n      const text = label.textContent?.toLowerCase() || '';\n      const dataLabel = label.getAttribute('data-label')?.toLowerCase() || '';\n      \n      if (text.includes(labelText.toLowerCase()) || dataLabel.includes(labelText.toLowerCase())) {\n        return label;\n      }\n    }\n    \n    return null;\n  }\n\n  /**\n   * Get form element associated with a label\n   */\n  private getAssociatedElement(labelElement: Element): Element | null {\n    // Try for attribute\n    const forAttribute = labelElement.getAttribute('for');\n    if (forAttribute) {\n      const associated = document.getElementById(forAttribute);\n      if (associated) return associated;\n    }\n    \n    // Try nested form element\n    const nested = labelElement.querySelector('input, select, textarea');\n    if (nested) return nested;\n    \n    // Try next sibling\n    let sibling = labelElement.nextElementSibling;\n    while (sibling) {\n      if (this.isRelevantFormElement(sibling)) {\n        return sibling;\n      }\n      sibling = sibling.nextElementSibling;\n    }\n    \n    return null;\n  }\n\n  /**\n   * Find text nodes containing specific text\n   */\n  private findTextNodes(container: Element, searchText: string): Text[] {\n    const walker = document.createTreeWalker(\n      container,\n      NodeFilter.SHOW_TEXT,\n      {\n        acceptNode: (node) => {\n          const text = node.textContent?.toLowerCase() || '';\n          return text.includes(searchText) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;\n        }\n      }\n    );\n    \n    const textNodes: Text[] = [];\n    let node: Node | null;\n    \n    while (node = walker.nextNode()) {\n      textNodes.push(node as Text);\n    }\n    \n    return textNodes;\n  }\n\n  /**\n   * Find form elements near a given element\n   */\n  private findNearbyFormElements(element: Element): Element[] {\n    const formElements: Element[] = [];\n    const searchDistance = 3; // How many levels up/down to search\n    \n    // Search in parent hierarchy\n    let parent = element.parentElement;\n    let level = 0;\n    \n    while (parent && level < searchDistance) {\n      const found = parent.querySelectorAll('input, select, textarea, button');\n      formElements.push(...Array.from(found));\n      parent = parent.parentElement;\n      level++;\n    }\n    \n    // Search in children\n    const children = element.querySelectorAll('input, select, textarea, button');\n    formElements.push(...Array.from(children));\n    \n    // Search in siblings\n    let sibling = element.previousElementSibling;\n    level = 0;\n    while (sibling && level < searchDistance) {\n      if (this.isRelevantFormElement(sibling)) {\n        formElements.push(sibling);\n      }\n      const found = sibling.querySelectorAll('input, select, textarea, button');\n      formElements.push(...Array.from(found));\n      sibling = sibling.previousElementSibling;\n      level++;\n    }\n    \n    sibling = element.nextElementSibling;\n    level = 0;\n    while (sibling && level < searchDistance) {\n      if (this.isRelevantFormElement(sibling)) {\n        formElements.push(sibling);\n      }\n      const found = sibling.querySelectorAll('input, select, textarea, button');\n      formElements.push(...Array.from(found));\n      sibling = sibling.nextElementSibling;\n      level++;\n    }\n    \n    return formElements;\n  }\n\n  /**\n   * Check if element is a relevant form element\n   */\n  private isRelevantFormElement(element: Element): boolean {\n    const tagName = element.tagName.toLowerCase();\n    \n    if (!['input', 'select', 'textarea'].includes(tagName)) {\n      return false;\n    }\n    \n    const inputType = (element as HTMLInputElement).type?.toLowerCase();\n    const excludedTypes = ['hidden', 'submit', 'button', 'reset'];\n    \n    if (tagName === 'input' && excludedTypes.includes(inputType)) {\n      return false;\n    }\n    \n    return this.isVisible(element);\n  }\n}\n","import { Photo } from '../types';\nimport { Logger } from './logger';\n\nconst logger = new Logger('Photos');\n\n/**\n * Extract photos from the current page using provided selectors\n */\nexport async function extractPhotos(selectors: string[]): Promise<Photo[]> {\n  logger.info('Extracting photos with selectors:', selectors);\n  \n  const photos: Photo[] = [];\n  const seenUrls = new Set<string>();\n  \n  // Find all image elements using the provided selectors\n  const imageElements = new Set<HTMLImageElement>();\n  \n  selectors.forEach(selector => {\n    const elements = document.querySelectorAll(selector);\n    elements.forEach(el => {\n      if (el instanceof HTMLImageElement) {\n        imageElements.add(el);\n      }\n    });\n  });\n  \n  logger.debug(`Found ${imageElements.size} image elements`);\n  \n  // Process each image element\n  for (const img of imageElements) {\n    try {\n      const photoUrls = extractImageUrls(img);\n      \n      for (const url of photoUrls) {\n        const absoluteUrl = makeAbsoluteUrl(url);\n        const cleanUrl = cleanImageUrl(absoluteUrl);\n        \n        if (cleanUrl && !seenUrls.has(cleanUrl) && isValidImageUrl(cleanUrl)) {\n          seenUrls.add(cleanUrl);\n          \n          const photo: Photo = {\n            url: cleanUrl,\n            width: img.naturalWidth || img.width || undefined,\n            height: img.naturalHeight || img.height || undefined,\n            isMain: isMainImage(img)\n          };\n          \n          photos.push(photo);\n        }\n      }\n    } catch (error) {\n      logger.warn('Error processing image:', error);\n    }\n  }\n  \n  // Sort photos - main images first, then by size (larger first)\n  photos.sort((a, b) => {\n    if (a.isMain && !b.isMain) return -1;\n    if (!a.isMain && b.isMain) return 1;\n    \n    const aSize = (a.width || 0) * (a.height || 0);\n    const bSize = (b.width || 0) * (b.height || 0);\n    return bSize - aSize;\n  });\n  \n  logger.info(`Extracted ${photos.length} unique photos`);\n  return photos;\n}\n\n/**\n * Extract all possible URLs from an image element (src, srcset, data attributes)\n */\nfunction extractImageUrls(img: HTMLImageElement): string[] {\n  const urls: string[] = [];\n  \n  // Get src attribute\n  if (img.src) {\n    urls.push(img.src);\n  }\n  \n  // Parse srcset for different resolutions\n  if (img.srcset) {\n    const srcsetUrls = parseSrcset(img.srcset);\n    urls.push(...srcsetUrls);\n  }\n  \n  // Check data attributes for lazy loading\n  const dataAttributes = ['data-src', 'data-original', 'data-lazy', 'data-full', 'data-large'];\n  dataAttributes.forEach(attr => {\n    const value = img.getAttribute(attr);\n    if (value) {\n      urls.push(value);\n    }\n  });\n  \n  // Check for background images on parent elements\n  let parent = img.parentElement;\n  while (parent && parent !== document.body) {\n    const bgImage = getComputedStyle(parent).backgroundImage;\n    if (bgImage && bgImage !== 'none') {\n      const match = bgImage.match(/url\\(['\"]?([^'\"]+)['\"]?\\)/);\n      if (match) {\n        urls.push(match[1]);\n      }\n    }\n    parent = parent.parentElement;\n  }\n  \n  return urls;\n}\n\n/**\n * Parse srcset attribute and return URLs sorted by resolution (highest first)\n */\nfunction parseSrcset(srcset: string): string[] {\n  const sources = srcset.split(',').map(s => s.trim());\n  const parsed: Array<{ url: string; width: number }> = [];\n  \n  sources.forEach(source => {\n    const parts = source.split(/\\s+/);\n    if (parts.length >= 1) {\n      const url = parts[0];\n      let width = 0;\n      \n      // Try to extract width descriptor\n      if (parts.length > 1) {\n        const descriptor = parts[1];\n        if (descriptor.endsWith('w')) {\n          width = parseInt(descriptor.slice(0, -1)) || 0;\n        } else if (descriptor.endsWith('x')) {\n          // For pixel density descriptors, assume a base width\n          const density = parseFloat(descriptor.slice(0, -1)) || 1;\n          width = Math.round(1920 * density); // Assume 1920px base width\n        }\n      }\n      \n      parsed.push({ url, width });\n    }\n  });\n  \n  // Sort by width (highest first) and return URLs\n  return parsed\n    .sort((a, b) => b.width - a.width)\n    .map(p => p.url);\n}\n\n/**\n * Convert relative URLs to absolute URLs\n */\nfunction makeAbsoluteUrl(url: string): string {\n  if (url.startsWith('http://') || url.startsWith('https://')) {\n    return url;\n  }\n  \n  if (url.startsWith('//')) {\n    return window.location.protocol + url;\n  }\n  \n  if (url.startsWith('/')) {\n    return window.location.origin + url;\n  }\n  \n  // Relative to current path\n  const currentPath = window.location.pathname.replace(/\\/[^\\/]*$/, '/');\n  return window.location.origin + currentPath + url;\n}\n\n/**\n * Clean image URL by removing tracking parameters and fragments\n */\nfunction cleanImageUrl(url: string): string {\n  try {\n    const urlObj = new URL(url);\n    \n    // Remove common tracking parameters\n    const trackingParams = [\n      'utm_source', 'utm_medium', 'utm_campaign', 'utm_content',\n      'gclid', 'fbclid', '_ga', 'ref', 'referrer'\n    ];\n    \n    trackingParams.forEach(param => {\n      urlObj.searchParams.delete(param);\n    });\n    \n    // Remove fragment\n    urlObj.hash = '';\n    \n    return urlObj.toString();\n  } catch (error) {\n    // If URL parsing fails, return original\n    return url;\n  }\n}\n\n/**\n * Check if URL points to a valid image\n */\nfunction isValidImageUrl(url: string): boolean {\n  try {\n    const urlObj = new URL(url);\n    const pathname = urlObj.pathname.toLowerCase();\n    \n    // Check file extension\n    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];\n    const hasImageExtension = imageExtensions.some(ext => pathname.endsWith(ext));\n    \n    if (hasImageExtension) {\n      return true;\n    }\n    \n    // Some sites serve images without extensions but with image content-type\n    // We'll assume it's valid if it's from a known image domain or path\n    const imageIndicators = [\n      '/image/', '/img/', '/photo/', '/picture/', '/gallery/',\n      'images.', 'photos.', 'media.', 'cdn.'\n    ];\n    \n    const hasImageIndicator = imageIndicators.some(indicator => \n      url.toLowerCase().includes(indicator)\n    );\n    \n    return hasImageIndicator;\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Determine if an image appears to be the main/hero image\n */\nfunction isMainImage(img: HTMLImageElement): boolean {\n  // Check class names and IDs for main image indicators\n  const mainImageIndicators = [\n    'hero', 'main', 'primary', 'featured', 'highlight',\n    'large', 'big', 'banner'\n  ];\n  \n  const className = img.className.toLowerCase();\n  const id = img.id.toLowerCase();\n  \n  const hasMainIndicator = mainImageIndicators.some(indicator =>\n    className.includes(indicator) || id.includes(indicator)\n  );\n  \n  if (hasMainIndicator) {\n    return true;\n  }\n  \n  // Check parent elements for main image indicators\n  let parent = img.parentElement;\n  let depth = 0;\n  while (parent && depth < 3) {\n    const parentClass = parent.className.toLowerCase();\n    const parentId = parent.id.toLowerCase();\n    \n    const hasParentMainIndicator = mainImageIndicators.some(indicator =>\n      parentClass.includes(indicator) || parentId.includes(indicator)\n    );\n    \n    if (hasParentMainIndicator) {\n      return true;\n    }\n    \n    parent = parent.parentElement;\n    depth++;\n  }\n  \n  // Check if it's the largest image (by dimensions)\n  const imageSize = (img.naturalWidth || img.width || 0) * (img.naturalHeight || img.height || 0);\n  if (imageSize > 500000) { // Roughly 800x600 or larger\n    return true;\n  }\n  \n  return false;\n}\n\n/**\n * Download photos to local storage (for manual upload fallback)\n */\nexport async function downloadPhotos(photos: Photo[]): Promise<void> {\n  logger.info(`Starting download of ${photos.length} photos`);\n  \n  const downloadPromises = photos.map(async (photo, index) => {\n    try {\n      const filename = `vehicle_photo_${index + 1}.jpg`;\n      \n      // Use Chrome downloads API\n      await chrome.runtime.sendMessage({\n        type: 'DOWNLOAD_PHOTO',\n        url: photo.url,\n        filename\n      });\n      \n      logger.debug(`Downloaded photo ${index + 1}: ${filename}`);\n    } catch (error) {\n      logger.error(`Failed to download photo ${index + 1}:`, error);\n    }\n  });\n  \n  await Promise.allSettled(downloadPromises);\n  logger.info('Photo download process completed');\n}\n\n/**\n * Convert image URLs to File objects for programmatic upload\n */\nexport async function urlsToFiles(photos: Photo[]): Promise<File[]> {\n  logger.info(`Converting ${photos.length} URLs to File objects`);\n  \n  const files: File[] = [];\n  \n  for (let i = 0; i < photos.length; i++) {\n    try {\n      const photo = photos[i];\n      const response = await fetch(photo.url);\n      \n      if (!response.ok) {\n        logger.warn(`Failed to fetch photo ${i + 1}: ${response.status}`);\n        continue;\n      }\n      \n      const blob = await response.blob();\n      \n      // Determine file extension from content type or URL\n      let extension = 'jpg';\n      const contentType = response.headers.get('content-type');\n      if (contentType) {\n        if (contentType.includes('png')) extension = 'png';\n        else if (contentType.includes('gif')) extension = 'gif';\n        else if (contentType.includes('webp')) extension = 'webp';\n      }\n      \n      const filename = `vehicle_photo_${i + 1}.${extension}`;\n      const file = new File([blob], filename, { type: blob.type || 'image/jpeg' });\n      \n      files.push(file);\n      logger.debug(`Converted photo ${i + 1} to File: ${filename}`);\n      \n    } catch (error) {\n      logger.error(`Failed to convert photo ${i + 1} to File:`, error);\n    }\n  }\n  \n  logger.info(`Successfully converted ${files.length} photos to File objects`);\n  return files;\n}\n","import { SiteAdapter, ScrapeResult, Vehicle, Dealer, Photo } from '../types';\nimport { SelectorProbe } from '../core/selectors';\nimport { normalizeVehicleData } from '../core/normalize';\nimport { extractPhotos } from '../core/photos';\nimport { Logger } from '../core/logger';\n\nexport class AutoTraderAdapter implements SiteAdapter {\n  name = 'AutoTrader';\n  hostnames = ['autotrader.com', 'www.autotrader.com'];\n  \n  private logger = new Logger('AutoTrader');\n  private probe = new SelectorProbe();\n\n  isVehiclePage(url: string): boolean {\n    return /\\/cars-for-sale\\/vehicledetails\\.xhtml|\\/vehicle\\/\\d+/i.test(url);\n  }\n\n  async scrape(): Promise<ScrapeResult> {\n    this.logger.info('Starting AutoTrader scrape');\n    \n    const warnings: string[] = [];\n    const vehicle: Vehicle = {};\n    const dealer: Dealer = {};\n    \n    try {\n      // Extract title information (year, make, model, trim)\n      await this.extractTitleInfo(vehicle, warnings);\n      \n      // Extract price and mileage\n      await this.extractPriceAndMileage(vehicle, warnings);\n      \n      // Extract vehicle specifications\n      await this.extractSpecs(vehicle, warnings);\n      \n      // Extract dealer information\n      await this.extractDealerInfo(dealer, warnings);\n      \n      // Extract VIN\n      await this.extractVIN(vehicle, warnings);\n      \n      // Extract description\n      await this.extractDescription(vehicle, warnings);\n      \n      // Extract photos\n      const photos = await this.extractPhotos(warnings);\n      \n      // Normalize the data\n      const normalizedVehicle = normalizeVehicleData(vehicle);\n      \n      const result: ScrapeResult = {\n        vehicle: normalizedVehicle,\n        dealer,\n        photos,\n        sourceUrl: window.location.href,\n        scrapedAt: Date.now(),\n        warnings,\n        id: `autotrader_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n      };\n      \n      this.logger.info('AutoTrader scrape completed', result);\n      return result;\n      \n    } catch (error) {\n      this.logger.error('AutoTrader scrape failed:', error);\n      throw new Error(`AutoTrader scraping failed: ${(error as Error).message}`);\n    }\n  }\n\n  private async extractTitleInfo(vehicle: Vehicle, warnings: string[]): Promise<void> {\n    // Try multiple selectors for the vehicle title\n    const titleSelectors = [\n      '.vehicle-title h1',\n      '[data-cmp=\"vehicleTitle\"]',\n      '.vehicle-header h1',\n      'h1[data-cmp=\"vehicleTitle\"]',\n      '.vdp-header h1'\n    ];\n    \n    const titleElement = this.probe.findElement(titleSelectors);\n    \n    if (titleElement) {\n      const titleText = titleElement.textContent?.trim() || '';\n      this.logger.debug('Found title:', titleText);\n      \n      // Parse title like \"2023 Honda Civic LX\"\n      const titleMatch = titleText.match(/(\\d{4})\\s+([A-Za-z]+)\\s+([A-Za-z0-9\\s]+?)(?:\\s+([A-Za-z0-9\\s]+))?$/);\n      \n      if (titleMatch) {\n        vehicle.year = parseInt(titleMatch[1]);\n        vehicle.make = titleMatch[2];\n        \n        // Split model and trim\n        const remaining = titleMatch[3].trim();\n        const parts = remaining.split(/\\s+/);\n        vehicle.model = parts[0];\n        \n        if (parts.length > 1) {\n          vehicle.trim = parts.slice(1).join(' ');\n        }\n        \n        if (titleMatch[4]) {\n          vehicle.trim = (vehicle.trim ? vehicle.trim + ' ' : '') + titleMatch[4];\n        }\n      } else {\n        warnings.push('Could not parse vehicle title format');\n      }\n    } else {\n      warnings.push('Vehicle title not found');\n    }\n  }\n\n  private async extractPriceAndMileage(vehicle: Vehicle, warnings: string[]): Promise<void> {\n    // Extract price\n    const priceSelectors = [\n      '[data-cmp=\"firstPrice\"]',\n      '.first-price',\n      '.vehicle-price .price-value',\n      '.price-section .price',\n      '[data-testid=\"price\"]'\n    ];\n    \n    const priceElement = this.probe.findElement(priceSelectors);\n    if (priceElement) {\n      const priceText = priceElement.textContent?.replace(/[$,]/g, '') || '';\n      const priceMatch = priceText.match(/(\\d+)/);\n      if (priceMatch) {\n        vehicle.price = parseInt(priceMatch[1]);\n      }\n    } else {\n      warnings.push('Price not found');\n    }\n    \n    // Extract mileage\n    const mileageSelectors = [\n      '[data-cmp=\"mileage\"]',\n      '.vehicle-mileage',\n      '.mileage-value',\n      '.specs-section .mileage'\n    ];\n    \n    const mileageElement = this.probe.findElement(mileageSelectors);\n    if (mileageElement) {\n      const mileageText = mileageElement.textContent?.replace(/[,\\s]/g, '') || '';\n      const mileageMatch = mileageText.match(/(\\d+)/);\n      if (mileageMatch) {\n        vehicle.mileage = parseInt(mileageMatch[1]);\n      }\n    } else {\n      // Try regex search on page text\n      const mileageRegex = /(\\d{1,3}(?:,\\d{3})*)\\s*miles?/i;\n      const pageText = document.body.textContent || '';\n      const mileageMatch = pageText.match(mileageRegex);\n      if (mileageMatch) {\n        vehicle.mileage = parseInt(mileageMatch[1].replace(/,/g, ''));\n      } else {\n        warnings.push('Mileage not found');\n      }\n    }\n  }\n\n  private async extractSpecs(vehicle: Vehicle, _warnings: string[]): Promise<void> {\n    // Look for specs section\n    const specsSection = this.probe.findElement([\n      '.vehicle-specs',\n      '.specifications',\n      '.specs-section',\n      '[data-cmp=\"vehicleSpecs\"]'\n    ]);\n    \n    if (specsSection) {\n      const specItems = specsSection.querySelectorAll('li, .spec-item, .specification-item');\n      \n      specItems.forEach(item => {\n        const text = item.textContent?.toLowerCase() || '';\n        const value = item.textContent?.trim() || '';\n        \n        if (text.includes('transmission')) {\n          vehicle.transmission = this.extractSpecValue(value, 'transmission');\n        } else if (text.includes('drivetrain') || text.includes('drive')) {\n          vehicle.drivetrain = this.extractSpecValue(value, 'drivetrain');\n        } else if (text.includes('engine')) {\n          vehicle.engine = this.extractSpecValue(value, 'engine');\n        } else if (text.includes('fuel')) {\n          vehicle.fuelType = this.extractSpecValue(value, 'fuel');\n        } else if (text.includes('exterior') && text.includes('color')) {\n          vehicle.exteriorColor = this.extractSpecValue(value, 'exterior color');\n        } else if (text.includes('interior') && text.includes('color')) {\n          vehicle.interiorColor = this.extractSpecValue(value, 'interior color');\n        } else if (text.includes('body') && text.includes('style')) {\n          vehicle.bodyStyle = this.extractSpecValue(value, 'body style');\n        }\n      });\n    }\n    \n    // Try alternative selectors for specific fields\n    if (!vehicle.transmission) {\n      const transmissionEl = this.probe.findByLabel(['transmission', 'trans']);\n      if (transmissionEl) {\n        vehicle.transmission = transmissionEl.textContent?.trim();\n      }\n    }\n    \n    if (!vehicle.exteriorColor) {\n      const colorEl = this.probe.findByLabel(['exterior color', 'color', 'ext color']);\n      if (colorEl) {\n        vehicle.exteriorColor = colorEl.textContent?.trim();\n      }\n    }\n  }\n\n  private extractSpecValue(fullText: string, specType: string): string {\n    // Remove the spec label and return the value\n    const parts = fullText.split(':');\n    if (parts.length > 1) {\n      return parts[1].trim();\n    }\n    \n    // Try to extract after the spec type\n    const regex = new RegExp(specType + '\\\\s*:?\\\\s*([^\\\\n\\\\r]+)', 'i');\n    const match = fullText.match(regex);\n    return match ? match[1].trim() : fullText.trim();\n  }\n\n  private async extractDealerInfo(dealer: Dealer, _warnings: string[]): Promise<void> {\n    // Extract dealer name\n    const dealerNameSelectors = [\n      '.dealer-name',\n      '[data-cmp=\"dealerName\"]',\n      '.dealer-info .name',\n      '.seller-name'\n    ];\n    \n    const dealerNameElement = this.probe.findElement(dealerNameSelectors);\n    if (dealerNameElement) {\n      dealer.name = dealerNameElement.textContent?.trim();\n    }\n    \n    // Extract dealer contact info\n    const contactSelectors = [\n      '.dealer-contact',\n      '.contact-info',\n      '[data-cmp=\"dealerContact\"]'\n    ];\n    \n    const contactElement = this.probe.findElement(contactSelectors);\n    if (contactElement) {\n      const contactText = contactElement.textContent || '';\n      \n      // Extract phone\n      const phoneMatch = contactText.match(/(\\d{3}[-.\\s]?\\d{3}[-.\\s]?\\d{4})/);\n      if (phoneMatch) {\n        dealer.phone = phoneMatch[1];\n      }\n      \n      // Extract address components\n      const addressMatch = contactText.match(/([A-Za-z\\s]+),\\s*([A-Z]{2})\\s*(\\d{5})/);\n      if (addressMatch) {\n        dealer.city = addressMatch[1].trim();\n        dealer.state = addressMatch[2];\n        dealer.zip = addressMatch[3];\n      }\n    }\n  }\n\n  private async extractVIN(vehicle: Vehicle, warnings: string[]): Promise<void> {\n    // Look for VIN in labeled fields\n    const vinElement = this.probe.findByLabel(['vin', 'vehicle identification number']);\n    \n    if (vinElement) {\n      vehicle.vin = vinElement.textContent?.trim();\n    } else {\n      // Use regex on page text\n      const vinRegex = /\\b[A-HJ-NPR-Z0-9]{17}\\b/;\n      const pageText = document.body.textContent || '';\n      const vinMatch = pageText.match(vinRegex);\n      if (vinMatch) {\n        vehicle.vin = vinMatch[0];\n      } else {\n        warnings.push('VIN not found');\n      }\n    }\n  }\n\n  private async extractDescription(vehicle: Vehicle, warnings: string[]): Promise<void> {\n    const descriptionSelectors = [\n      '.vehicle-description',\n      '[data-cmp=\"vehicleDescription\"]',\n      '.description-content',\n      '.vehicle-comments'\n    ];\n    \n    const descriptionElement = this.probe.findElement(descriptionSelectors);\n    if (descriptionElement) {\n      vehicle.description = descriptionElement.textContent?.trim();\n    } else {\n      warnings.push('Description not found');\n    }\n  }\n\n  private async extractPhotos(warnings: string[]): Promise<Photo[]> {\n    try {\n      return await extractPhotos([\n        '.vehicle-gallery img',\n        '[data-cmp=\"vehicleGallery\"] img',\n        '.gallery-thumbnail img',\n        '.hero-image img'\n      ]);\n    } catch (error) {\n      warnings.push('Failed to extract photos: ' + (error as Error).message);\n      return [];\n    }\n  }\n}\n","import { SiteAdapter, ScrapeResult, Vehicle, Dealer, Photo } from '../types';\nimport { SelectorProbe } from '../core/selectors';\nimport { normalizeVehicleData } from '../core/normalize';\nimport { extractPhotos } from '../core/photos';\nimport { Logger } from '../core/logger';\n\nexport class CarsDotComAdapter implements SiteAdapter {\n  name = 'Cars.com';\n  hostnames = ['cars.com', 'www.cars.com'];\n  \n  private logger = new Logger('Cars.com');\n  private probe = new SelectorProbe();\n\n  isVehiclePage(url: string): boolean {\n    return /\\/vehicledetail\\/|\\/listing\\/|\\/vehicle\\//i.test(url);\n  }\n\n  async scrape(): Promise<ScrapeResult> {\n    this.logger.info('Starting Cars.com scrape');\n    \n    const warnings: string[] = [];\n    const vehicle: Vehicle = {};\n    const dealer: Dealer = {};\n    \n    try {\n      // Extract title information\n      await this.extractTitleInfo(vehicle, warnings);\n      \n      // Extract price and mileage\n      await this.extractPriceAndMileage(vehicle, warnings);\n      \n      // Extract vehicle specifications\n      await this.extractSpecs(vehicle, warnings);\n      \n      // Extract dealer information\n      await this.extractDealerInfo(dealer, warnings);\n      \n      // Extract VIN\n      await this.extractVIN(vehicle, warnings);\n      \n      // Extract description\n      await this.extractDescription(vehicle, warnings);\n      \n      // Extract photos\n      const photos = await this.extractPhotos(warnings);\n      \n      // Normalize the data\n      const normalizedVehicle = normalizeVehicleData(vehicle);\n      \n      const result: ScrapeResult = {\n        vehicle: normalizedVehicle,\n        dealer,\n        photos,\n        sourceUrl: window.location.href,\n        scrapedAt: Date.now(),\n        warnings,\n        id: `cars_com_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n      };\n      \n      this.logger.info('Cars.com scrape completed', result);\n      return result;\n      \n    } catch (error) {\n      this.logger.error('Cars.com scrape failed:', error);\n      throw new Error(`Cars.com scraping failed: ${(error as Error).message}`);\n    }\n  }\n\n  private async extractTitleInfo(vehicle: Vehicle, warnings: string[]): Promise<void> {\n    const titleSelectors = [\n      'h1[data-testid=\"structured-data-title\"]',\n      '.vehicle-title h1',\n      '.listing-title h1',\n      'h1.vehicle-info-title',\n      '[data-testid=\"vehicle-title\"]'\n    ];\n    \n    const titleElement = this.probe.findElement(titleSelectors);\n    \n    if (titleElement) {\n      const titleText = titleElement.textContent?.trim() || '';\n      this.logger.debug('Found title:', titleText);\n      \n      // Parse Cars.com title format\n      const titleMatch = titleText.match(/(\\d{4})\\s+([A-Za-z]+)\\s+([A-Za-z0-9\\s]+?)(?:\\s+([A-Za-z0-9\\s]+))?$/);\n      \n      if (titleMatch) {\n        vehicle.year = parseInt(titleMatch[1]);\n        vehicle.make = titleMatch[2];\n        \n        const remaining = titleMatch[3].trim();\n        const parts = remaining.split(/\\s+/);\n        vehicle.model = parts[0];\n        \n        if (parts.length > 1) {\n          vehicle.trim = parts.slice(1).join(' ');\n        }\n        \n        if (titleMatch[4]) {\n          vehicle.trim = (vehicle.trim ? vehicle.trim + ' ' : '') + titleMatch[4];\n        }\n      } else {\n        warnings.push('Could not parse vehicle title format');\n      }\n    } else {\n      warnings.push('Vehicle title not found');\n    }\n  }\n\n  private async extractPriceAndMileage(vehicle: Vehicle, warnings: string[]): Promise<void> {\n    // Extract price\n    const priceSelectors = [\n      '[data-testid=\"price\"]',\n      '.primary-price',\n      '.vehicle-price .price',\n      '.listing-price'\n    ];\n    \n    const priceElement = this.probe.findElement(priceSelectors);\n    if (priceElement) {\n      const priceText = priceElement.textContent?.replace(/[$,]/g, '') || '';\n      const priceMatch = priceText.match(/(\\d+)/);\n      if (priceMatch) {\n        vehicle.price = parseInt(priceMatch[1]);\n      }\n    } else {\n      warnings.push('Price not found');\n    }\n    \n    // Extract mileage\n    const mileageSelectors = [\n      '[data-testid=\"mileage\"]',\n      '.vehicle-mileage',\n      '.listing-mileage',\n      '.mileage-display'\n    ];\n    \n    const mileageElement = this.probe.findElement(mileageSelectors);\n    if (mileageElement) {\n      const mileageText = mileageElement.textContent?.replace(/[,\\s]/g, '') || '';\n      const mileageMatch = mileageText.match(/(\\d+)/);\n      if (mileageMatch) {\n        vehicle.mileage = parseInt(mileageMatch[1]);\n      }\n    } else {\n      const mileageRegex = /(\\d{1,3}(?:,\\d{3})*)\\s*miles?/i;\n      const pageText = document.body.textContent || '';\n      const mileageMatch = pageText.match(mileageRegex);\n      if (mileageMatch) {\n        vehicle.mileage = parseInt(mileageMatch[1].replace(/,/g, ''));\n      } else {\n        warnings.push('Mileage not found');\n      }\n    }\n  }\n\n  private async extractSpecs(vehicle: Vehicle, _warnings: string[]): Promise<void> {\n    // Cars.com often has a specifications section\n    const specsSection = this.probe.findElement([\n      '[data-testid=\"specifications\"]',\n      '.vehicle-specs',\n      '.specifications-section',\n      '.vehicle-features'\n    ]);\n    \n    if (specsSection) {\n      const specItems = specsSection.querySelectorAll('li, .spec-row, .feature-item, dt, dd');\n      \n      let currentLabel = '';\n      specItems.forEach((item, _index) => {\n        const text = item.textContent?.toLowerCase() || '';\n        const value = item.textContent?.trim() || '';\n        \n        // Handle dt/dd pairs\n        if (item.tagName.toLowerCase() === 'dt') {\n          currentLabel = text;\n        } else if (item.tagName.toLowerCase() === 'dd' && currentLabel) {\n          this.parseSpecField(currentLabel, value, vehicle);\n          currentLabel = '';\n        } else {\n          // Handle other formats\n          if (text.includes('transmission')) {\n            vehicle.transmission = this.extractSpecValue(value, 'transmission');\n          } else if (text.includes('drivetrain') || text.includes('drive type')) {\n            vehicle.drivetrain = this.extractSpecValue(value, 'drivetrain');\n          } else if (text.includes('engine')) {\n            vehicle.engine = this.extractSpecValue(value, 'engine');\n          } else if (text.includes('fuel type')) {\n            vehicle.fuelType = this.extractSpecValue(value, 'fuel type');\n          } else if (text.includes('exterior color')) {\n            vehicle.exteriorColor = this.extractSpecValue(value, 'exterior color');\n          } else if (text.includes('interior color')) {\n            vehicle.interiorColor = this.extractSpecValue(value, 'interior color');\n          } else if (text.includes('body style') || text.includes('body type')) {\n            vehicle.bodyStyle = this.extractSpecValue(value, 'body style');\n          }\n        }\n      });\n    }\n    \n    // Try data attributes that Cars.com might use\n    const dataAttributes = document.querySelector('[data-make], [data-model], [data-year]');\n    if (dataAttributes) {\n      if (!vehicle.make && dataAttributes.getAttribute('data-make')) {\n        vehicle.make = dataAttributes.getAttribute('data-make')!;\n      }\n      if (!vehicle.model && dataAttributes.getAttribute('data-model')) {\n        vehicle.model = dataAttributes.getAttribute('data-model')!;\n      }\n      if (!vehicle.year && dataAttributes.getAttribute('data-year')) {\n        vehicle.year = parseInt(dataAttributes.getAttribute('data-year')!);\n      }\n    }\n  }\n\n  private parseSpecField(label: string, value: string, vehicle: Vehicle): void {\n    if (label.includes('transmission')) {\n      vehicle.transmission = value;\n    } else if (label.includes('drivetrain') || label.includes('drive')) {\n      vehicle.drivetrain = value;\n    } else if (label.includes('engine')) {\n      vehicle.engine = value;\n    } else if (label.includes('fuel')) {\n      vehicle.fuelType = value;\n    } else if (label.includes('exterior') && label.includes('color')) {\n      vehicle.exteriorColor = value;\n    } else if (label.includes('interior') && label.includes('color')) {\n      vehicle.interiorColor = value;\n    } else if (label.includes('body')) {\n      vehicle.bodyStyle = value;\n    }\n  }\n\n  private extractSpecValue(fullText: string, specType: string): string {\n    const parts = fullText.split(':');\n    if (parts.length > 1) {\n      return parts[1].trim();\n    }\n    \n    const regex = new RegExp(specType + '\\\\s*:?\\\\s*([^\\\\n\\\\r]+)', 'i');\n    const match = fullText.match(regex);\n    return match ? match[1].trim() : fullText.trim();\n  }\n\n  private async extractDealerInfo(dealer: Dealer, _warnings: string[]): Promise<void> {\n    // Extract dealer name\n    const dealerNameSelectors = [\n      '[data-testid=\"dealer-name\"]',\n      '.dealer-name',\n      '.seller-name',\n      '.dealership-name'\n    ];\n    \n    const dealerNameElement = this.probe.findElement(dealerNameSelectors);\n    if (dealerNameElement) {\n      dealer.name = dealerNameElement.textContent?.trim();\n    }\n    \n    // Extract dealer contact info\n    const contactSelectors = [\n      '[data-testid=\"dealer-contact\"]',\n      '.dealer-contact',\n      '.contact-info',\n      '.dealer-info'\n    ];\n    \n    const contactElement = this.probe.findElement(contactSelectors);\n    if (contactElement) {\n      const contactText = contactElement.textContent || '';\n      \n      // Extract phone\n      const phoneMatch = contactText.match(/(\\d{3}[-.\\s]?\\d{3}[-.\\s]?\\d{4})/);\n      if (phoneMatch) {\n        dealer.phone = phoneMatch[1];\n      }\n      \n      // Extract address\n      const addressMatch = contactText.match(/([A-Za-z\\s]+),\\s*([A-Z]{2})\\s*(\\d{5})/);\n      if (addressMatch) {\n        dealer.city = addressMatch[1].trim();\n        dealer.state = addressMatch[2];\n        dealer.zip = addressMatch[3];\n      }\n    }\n  }\n\n  private async extractVIN(vehicle: Vehicle, warnings: string[]): Promise<void> {\n    // Look for VIN in data attributes first\n    const vinDataElement = document.querySelector('[data-vin]');\n    if (vinDataElement) {\n      vehicle.vin = vinDataElement.getAttribute('data-vin') || undefined;\n    } else {\n      // Look for VIN in labeled fields\n      const vinElement = this.probe.findByLabel(['vin', 'vehicle identification number']);\n      \n      if (vinElement) {\n        vehicle.vin = vinElement.textContent?.trim();\n      } else {\n        // Use regex on page text\n        const vinRegex = /\\b[A-HJ-NPR-Z0-9]{17}\\b/;\n        const pageText = document.body.textContent || '';\n        const vinMatch = pageText.match(vinRegex);\n        if (vinMatch) {\n          vehicle.vin = vinMatch[0];\n        } else {\n          warnings.push('VIN not found');\n        }\n      }\n    }\n  }\n\n  private async extractDescription(vehicle: Vehicle, warnings: string[]): Promise<void> {\n    const descriptionSelectors = [\n      '[data-testid=\"description\"]',\n      '.vehicle-description',\n      '.listing-description',\n      '.description-content'\n    ];\n    \n    const descriptionElement = this.probe.findElement(descriptionSelectors);\n    if (descriptionElement) {\n      vehicle.description = descriptionElement.textContent?.trim();\n    } else {\n      warnings.push('Description not found');\n    }\n  }\n\n  private async extractPhotos(warnings: string[]): Promise<Photo[]> {\n    try {\n      return await extractPhotos([\n        '[data-testid^=\"gallery-image\"] img',\n        '.vehicle-gallery img',\n        '.image-gallery img',\n        '.listing-photos img'\n      ]);\n    } catch (error) {\n      warnings.push('Failed to extract photos: ' + (error as Error).message);\n      return [];\n    }\n  }\n}\n","import { SiteAdapter, ScrapeResult, Vehicle, Dealer, Photo } from '../types';\nimport { SelectorProbe } from '../core/selectors';\nimport { normalizeVehicleData } from '../core/normalize';\nimport { extractPhotos } from '../core/photos';\nimport { Logger } from '../core/logger';\n\nexport class CarGurusAdapter implements SiteAdapter {\n  name = 'CarGurus';\n  hostnames = ['cargurus.com', 'www.cargurus.com'];\n  \n  private logger = new Logger('CarGurus');\n  private probe = new SelectorProbe();\n\n  isVehiclePage(url: string): boolean {\n    return /\\/cars\\/l-|\\/vehicle\\/\\d+/i.test(url);\n  }\n\n  async scrape(): Promise<ScrapeResult> {\n    this.logger.info('Starting CarGurus scrape');\n    \n    const warnings: string[] = [];\n    const vehicle: Vehicle = {};\n    const dealer: Dealer = {};\n    \n    try {\n      // Extract title information\n      await this.extractTitleInfo(vehicle, warnings);\n      \n      // Extract price and mileage\n      await this.extractPriceAndMileage(vehicle, warnings);\n      \n      // Extract vehicle specifications\n      await this.extractSpecs(vehicle, warnings);\n      \n      // Extract dealer information\n      await this.extractDealerInfo(dealer, warnings);\n      \n      // Extract VIN\n      await this.extractVIN(vehicle, warnings);\n      \n      // Extract description\n      await this.extractDescription(vehicle, warnings);\n      \n      // Extract photos\n      const photos = await this.extractPhotos(warnings);\n      \n      // Normalize the data\n      const normalizedVehicle = normalizeVehicleData(vehicle);\n      \n      const result: ScrapeResult = {\n        vehicle: normalizedVehicle,\n        dealer,\n        photos,\n        sourceUrl: window.location.href,\n        scrapedAt: Date.now(),\n        warnings,\n        id: `cargurus_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n      };\n      \n      this.logger.info('CarGurus scrape completed', result);\n      return result;\n      \n    } catch (error) {\n      this.logger.error('CarGurus scrape failed:', error);\n      throw new Error(`CarGurus scraping failed: ${(error as Error).message}`);\n    }\n  }\n\n  private async extractTitleInfo(vehicle: Vehicle, warnings: string[]): Promise<void> {\n    const titleSelectors = [\n      '.cg-listingDetail-model',\n      'h1[data-cg-ft=\"listing-title\"]',\n      '.listing-title h1',\n      '.vehicle-title',\n      '.vdp-header h1'\n    ];\n    \n    const titleElement = this.probe.findElement(titleSelectors);\n    \n    if (titleElement) {\n      const titleText = titleElement.textContent?.trim() || '';\n      this.logger.debug('Found title:', titleText);\n      \n      // CarGurus title format parsing\n      const titleMatch = titleText.match(/(\\d{4})\\s+([A-Za-z]+)\\s+([A-Za-z0-9\\s]+?)(?:\\s+([A-Za-z0-9\\s]+))?$/);\n      \n      if (titleMatch) {\n        vehicle.year = parseInt(titleMatch[1]);\n        vehicle.make = titleMatch[2];\n        \n        const remaining = titleMatch[3].trim();\n        const parts = remaining.split(/\\s+/);\n        vehicle.model = parts[0];\n        \n        if (parts.length > 1) {\n          vehicle.trim = parts.slice(1).join(' ');\n        }\n        \n        if (titleMatch[4]) {\n          vehicle.trim = (vehicle.trim ? vehicle.trim + ' ' : '') + titleMatch[4];\n        }\n      } else {\n        warnings.push('Could not parse vehicle title format');\n      }\n    } else {\n      warnings.push('Vehicle title not found');\n    }\n  }\n\n  private async extractPriceAndMileage(vehicle: Vehicle, warnings: string[]): Promise<void> {\n    // Extract price\n    const priceSelectors = [\n      '.cg-listingDetail-price',\n      '[data-cg-ft=\"listing-price\"]',\n      '.listing-price',\n      '.price-section .price'\n    ];\n    \n    const priceElement = this.probe.findElement(priceSelectors);\n    if (priceElement) {\n      const priceText = priceElement.textContent?.replace(/[$,]/g, '') || '';\n      const priceMatch = priceText.match(/(\\d+)/);\n      if (priceMatch) {\n        vehicle.price = parseInt(priceMatch[1]);\n      }\n    } else {\n      warnings.push('Price not found');\n    }\n    \n    // Extract mileage\n    const mileageSelectors = [\n      '.cg-listingDetail-mileage',\n      '[data-cg-ft=\"listing-mileage\"]',\n      '.listing-mileage',\n      '.mileage-display'\n    ];\n    \n    const mileageElement = this.probe.findElement(mileageSelectors);\n    if (mileageElement) {\n      const mileageText = mileageElement.textContent?.replace(/[,\\s]/g, '') || '';\n      const mileageMatch = mileageText.match(/(\\d+)/);\n      if (mileageMatch) {\n        vehicle.mileage = parseInt(mileageMatch[1]);\n      }\n    } else {\n      const mileageRegex = /(\\d{1,3}(?:,\\d{3})*)\\s*miles?/i;\n      const pageText = document.body.textContent || '';\n      const mileageMatch = pageText.match(mileageRegex);\n      if (mileageMatch) {\n        vehicle.mileage = parseInt(mileageMatch[1].replace(/,/g, ''));\n      } else {\n        warnings.push('Mileage not found');\n      }\n    }\n  }\n\n  private async extractSpecs(vehicle: Vehicle, _warnings: string[]): Promise<void> {\n    // CarGurus specifications section\n    const specsSection = this.probe.findElement([\n      '.cg-listingDetail-specs',\n      '.vehicle-specs',\n      '.specifications',\n      '.listing-specs'\n    ]);\n    \n    if (specsSection) {\n      const specItems = specsSection.querySelectorAll('li, .spec-item, .detail-item');\n      \n      specItems.forEach(item => {\n        const text = item.textContent?.toLowerCase() || '';\n        const value = item.textContent?.trim() || '';\n        \n        if (text.includes('transmission')) {\n          vehicle.transmission = this.extractSpecValue(value, 'transmission');\n        } else if (text.includes('drivetrain') || text.includes('drive type')) {\n          vehicle.drivetrain = this.extractSpecValue(value, 'drivetrain');\n        } else if (text.includes('engine')) {\n          vehicle.engine = this.extractSpecValue(value, 'engine');\n        } else if (text.includes('fuel')) {\n          vehicle.fuelType = this.extractSpecValue(value, 'fuel');\n        } else if (text.includes('exterior') && text.includes('color')) {\n          vehicle.exteriorColor = this.extractSpecValue(value, 'exterior color');\n        } else if (text.includes('interior') && text.includes('color')) {\n          vehicle.interiorColor = this.extractSpecValue(value, 'interior color');\n        } else if (text.includes('body') && (text.includes('style') || text.includes('type'))) {\n          vehicle.bodyStyle = this.extractSpecValue(value, 'body style');\n        }\n      });\n    }\n    \n    // Try alternative approaches for CarGurus specific layout\n    if (!vehicle.transmission) {\n      const transmissionEl = this.probe.findByLabel(['transmission', 'trans'], specsSection || undefined);\n      if (transmissionEl) {\n        vehicle.transmission = transmissionEl.textContent?.trim();\n      }\n    }\n    \n    if (!vehicle.exteriorColor) {\n      const colorEl = this.probe.findByLabel(['exterior color', 'color'], specsSection || undefined);\n      if (colorEl) {\n        vehicle.exteriorColor = colorEl.textContent?.trim();\n      }\n    }\n  }\n\n  private extractSpecValue(fullText: string, specType: string): string {\n    const parts = fullText.split(':');\n    if (parts.length > 1) {\n      return parts[1].trim();\n    }\n    \n    const regex = new RegExp(specType + '\\\\s*:?\\\\s*([^\\\\n\\\\r]+)', 'i');\n    const match = fullText.match(regex);\n    return match ? match[1].trim() : fullText.trim();\n  }\n\n  private async extractDealerInfo(dealer: Dealer, _warnings: string[]): Promise<void> {\n    // Extract dealer name\n    const dealerNameSelectors = [\n      '.cg-listingDetail-dealerName',\n      '[data-cg-ft=\"dealer-name\"]',\n      '.dealer-name',\n      '.seller-name'\n    ];\n    \n    const dealerNameElement = this.probe.findElement(dealerNameSelectors);\n    if (dealerNameElement) {\n      dealer.name = dealerNameElement.textContent?.trim();\n    }\n    \n    // Extract dealer contact info\n    const contactSelectors = [\n      '.cg-listingDetail-dealerContact',\n      '.dealer-contact',\n      '.contact-info',\n      '.dealer-info'\n    ];\n    \n    const contactElement = this.probe.findElement(contactSelectors);\n    if (contactElement) {\n      const contactText = contactElement.textContent || '';\n      \n      // Extract phone\n      const phoneMatch = contactText.match(/(\\d{3}[-.\\s]?\\d{3}[-.\\s]?\\d{4})/);\n      if (phoneMatch) {\n        dealer.phone = phoneMatch[1];\n      }\n      \n      // Extract address\n      const addressMatch = contactText.match(/([A-Za-z\\s]+),\\s*([A-Z]{2})\\s*(\\d{5})/);\n      if (addressMatch) {\n        dealer.city = addressMatch[1].trim();\n        dealer.state = addressMatch[2];\n        dealer.zip = addressMatch[3];\n      }\n    }\n  }\n\n  private async extractVIN(vehicle: Vehicle, warnings: string[]): Promise<void> {\n    // Look for VIN in CarGurus specific selectors\n    const vinElement = this.probe.findElement([\n      '.cg-listingDetail-vin',\n      '[data-cg-ft=\"vin\"]'\n    ]);\n    \n    if (vinElement) {\n      vehicle.vin = vinElement.textContent?.trim();\n    } else {\n      // Look for VIN in labeled fields\n      const vinLabelElement = this.probe.findByLabel(['vin', 'vehicle identification number']);\n      \n      if (vinLabelElement) {\n        vehicle.vin = vinLabelElement.textContent?.trim();\n      } else {\n        // Use regex on page text\n        const vinRegex = /\\b[A-HJ-NPR-Z0-9]{17}\\b/;\n        const pageText = document.body.textContent || '';\n        const vinMatch = pageText.match(vinRegex);\n        if (vinMatch) {\n          vehicle.vin = vinMatch[0];\n        } else {\n          warnings.push('VIN not found');\n        }\n      }\n    }\n  }\n\n  private async extractDescription(vehicle: Vehicle, warnings: string[]): Promise<void> {\n    const descriptionSelectors = [\n      '.cg-listingDetail-description',\n      '.vehicle-description',\n      '.listing-description',\n      '.description-content'\n    ];\n    \n    const descriptionElement = this.probe.findElement(descriptionSelectors);\n    if (descriptionElement) {\n      vehicle.description = descriptionElement.textContent?.trim();\n    } else {\n      warnings.push('Description not found');\n    }\n  }\n\n  private async extractPhotos(warnings: string[]): Promise<Photo[]> {\n    try {\n      return await extractPhotos([\n        '.cg-listingDetail-photoViewer img',\n        '.vehicle-photos img',\n        '.image-gallery img',\n        '.listing-gallery img'\n      ]);\n    } catch (error) {\n      warnings.push('Failed to extract photos: ' + (error as Error).message);\n      return [];\n    }\n  }\n}\n","import { SiteAdapter, ScrapeResult, Vehicle, Dealer, Photo } from '../types';\nimport { SelectorProbe } from '../core/selectors';\nimport { normalizeVehicleData } from '../core/normalize';\nimport { extractPhotos } from '../core/photos';\nimport { Logger } from '../core/logger';\n\nexport class DealerDotComAdapter implements SiteAdapter {\n  name = 'Dealer.com';\n  hostnames = ['dealer.com', 'www.dealer.com'];\n  \n  private logger = new Logger('Dealer.com');\n  private probe = new SelectorProbe();\n\n  isVehiclePage(url: string): boolean {\n    return /\\/inventory\\/|\\/vehicle\\/|\\/vdp\\//i.test(url);\n  }\n\n  async scrape(): Promise<ScrapeResult> {\n    this.logger.info('Starting Dealer.com scrape');\n    \n    const warnings: string[] = [];\n    const vehicle: Vehicle = {};\n    const dealer: Dealer = {};\n    \n    try {\n      // Extract title information\n      await this.extractTitleInfo(vehicle, warnings);\n      \n      // Extract price and mileage\n      await this.extractPriceAndMileage(vehicle, warnings);\n      \n      // Extract vehicle specifications\n      await this.extractSpecs(vehicle, warnings);\n      \n      // Extract dealer information\n      await this.extractDealerInfo(dealer, warnings);\n      \n      // Extract VIN\n      await this.extractVIN(vehicle, warnings);\n      \n      // Extract description\n      await this.extractDescription(vehicle, warnings);\n      \n      // Extract photos\n      const photos = await this.extractPhotos(warnings);\n      \n      // Normalize the data\n      const normalizedVehicle = normalizeVehicleData(vehicle);\n      \n      const result: ScrapeResult = {\n        vehicle: normalizedVehicle,\n        dealer,\n        photos,\n        sourceUrl: window.location.href,\n        scrapedAt: Date.now(),\n        warnings,\n        id: `dealer_com_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n      };\n      \n      this.logger.info('Dealer.com scrape completed', result);\n      return result;\n      \n    } catch (error) {\n      this.logger.error('Dealer.com scrape failed:', error);\n      throw new Error(`Dealer.com scraping failed: ${(error as Error).message}`);\n    }\n  }\n\n  private async extractTitleInfo(vehicle: Vehicle, warnings: string[]): Promise<void> {\n    const titleSelectors = [\n      '.vdp-header h1',\n      '.vehicle-title h1',\n      '.inventory-title',\n      '.model-year-make',\n      'h1.vehicle-name'\n    ];\n    \n    const titleElement = this.probe.findElement(titleSelectors);\n    \n    if (titleElement) {\n      const titleText = titleElement.textContent?.trim() || '';\n      this.logger.debug('Found title:', titleText);\n      \n      // Parse Dealer.com title format\n      const titleMatch = titleText.match(/(\\d{4})\\s+([A-Za-z]+)\\s+([A-Za-z0-9\\s]+?)(?:\\s+([A-Za-z0-9\\s]+))?$/);\n      \n      if (titleMatch) {\n        vehicle.year = parseInt(titleMatch[1]);\n        vehicle.make = titleMatch[2];\n        \n        const remaining = titleMatch[3].trim();\n        const parts = remaining.split(/\\s+/);\n        vehicle.model = parts[0];\n        \n        if (parts.length > 1) {\n          vehicle.trim = parts.slice(1).join(' ');\n        }\n        \n        if (titleMatch[4]) {\n          vehicle.trim = (vehicle.trim ? vehicle.trim + ' ' : '') + titleMatch[4];\n        }\n      } else {\n        warnings.push('Could not parse vehicle title format');\n      }\n    } else {\n      warnings.push('Vehicle title not found');\n    }\n  }\n\n  private async extractPriceAndMileage(vehicle: Vehicle, warnings: string[]): Promise<void> {\n    // Extract price\n    const priceSelectors = [\n      '.vehicle-price .price',\n      '.price-value',\n      '.listing-price',\n      '.vdp-price',\n      '.msrp-price'\n    ];\n    \n    const priceElement = this.probe.findElement(priceSelectors);\n    if (priceElement) {\n      const priceText = priceElement.textContent?.replace(/[$,]/g, '') || '';\n      const priceMatch = priceText.match(/(\\d+)/);\n      if (priceMatch) {\n        vehicle.price = parseInt(priceMatch[1]);\n      }\n    } else {\n      warnings.push('Price not found');\n    }\n    \n    // Extract mileage\n    const mileageSelectors = [\n      '.vehicle-mileage',\n      '.mileage-value',\n      '.odometer',\n      '.vdp-mileage'\n    ];\n    \n    const mileageElement = this.probe.findElement(mileageSelectors);\n    if (mileageElement) {\n      const mileageText = mileageElement.textContent?.replace(/[,\\s]/g, '') || '';\n      const mileageMatch = mileageText.match(/(\\d+)/);\n      if (mileageMatch) {\n        vehicle.mileage = parseInt(mileageMatch[1]);\n      }\n    } else {\n      const mileageRegex = /(\\d{1,3}(?:,\\d{3})*)\\s*miles?/i;\n      const pageText = document.body.textContent || '';\n      const mileageMatch = pageText.match(mileageRegex);\n      if (mileageMatch) {\n        vehicle.mileage = parseInt(mileageMatch[1].replace(/,/g, ''));\n      } else {\n        warnings.push('Mileage not found');\n      }\n    }\n  }\n\n  private async extractSpecs(vehicle: Vehicle, _warnings: string[]): Promise<void> {\n    // Dealer.com specifications section\n    const specsSection = this.probe.findElement([\n      '.vehicle-specs',\n      '.specifications',\n      '.vehicle-features',\n      '.vdp-specs'\n    ]);\n    \n    if (specsSection) {\n      const specItems = specsSection.querySelectorAll('li, .spec-item, .feature-item, tr');\n      \n      specItems.forEach(item => {\n        const text = item.textContent?.toLowerCase() || '';\n        const value = item.textContent?.trim() || '';\n        \n        if (text.includes('transmission')) {\n          vehicle.transmission = this.extractSpecValue(value, 'transmission');\n        } else if (text.includes('drivetrain') || text.includes('drive type')) {\n          vehicle.drivetrain = this.extractSpecValue(value, 'drivetrain');\n        } else if (text.includes('engine')) {\n          vehicle.engine = this.extractSpecValue(value, 'engine');\n        } else if (text.includes('fuel')) {\n          vehicle.fuelType = this.extractSpecValue(value, 'fuel');\n        } else if (text.includes('exterior') && text.includes('color')) {\n          vehicle.exteriorColor = this.extractSpecValue(value, 'exterior color');\n        } else if (text.includes('interior') && text.includes('color')) {\n          vehicle.interiorColor = this.extractSpecValue(value, 'interior color');\n        } else if (text.includes('body') && (text.includes('style') || text.includes('type'))) {\n          vehicle.bodyStyle = this.extractSpecValue(value, 'body style');\n        }\n      });\n    }\n    \n    // Try table format common on dealer sites\n    const specTable = this.probe.findElement(['.specs-table', '.vehicle-details-table']);\n    if (specTable) {\n      const rows = specTable.querySelectorAll('tr');\n      rows.forEach(row => {\n        const cells = row.querySelectorAll('td, th');\n        if (cells.length >= 2) {\n          const label = cells[0].textContent?.toLowerCase() || '';\n          const value = cells[1].textContent?.trim() || '';\n          \n          if (label.includes('transmission')) {\n            vehicle.transmission = value;\n          } else if (label.includes('drivetrain') || label.includes('drive')) {\n            vehicle.drivetrain = value;\n          } else if (label.includes('engine')) {\n            vehicle.engine = value;\n          } else if (label.includes('fuel')) {\n            vehicle.fuelType = value;\n          } else if (label.includes('exterior') && label.includes('color')) {\n            vehicle.exteriorColor = value;\n          } else if (label.includes('interior') && label.includes('color')) {\n            vehicle.interiorColor = value;\n          } else if (label.includes('body')) {\n            vehicle.bodyStyle = value;\n          }\n        }\n      });\n    }\n  }\n\n  private extractSpecValue(fullText: string, specType: string): string {\n    const parts = fullText.split(':');\n    if (parts.length > 1) {\n      return parts[1].trim();\n    }\n    \n    const regex = new RegExp(specType + '\\\\s*:?\\\\s*([^\\\\n\\\\r]+)', 'i');\n    const match = fullText.match(regex);\n    return match ? match[1].trim() : fullText.trim();\n  }\n\n  private async extractDealerInfo(dealer: Dealer, _warnings: string[]): Promise<void> {\n    // Extract dealer name\n    const dealerNameSelectors = [\n      '.dealer-name',\n      '.dealership-name',\n      '.seller-name',\n      '.vdp-dealer-name'\n    ];\n    \n    const dealerNameElement = this.probe.findElement(dealerNameSelectors);\n    if (dealerNameElement) {\n      dealer.name = dealerNameElement.textContent?.trim();\n    }\n    \n    // Extract dealer contact info\n    const contactSelectors = [\n      '.dealer-contact',\n      '.contact-info',\n      '.dealer-info',\n      '.dealership-contact'\n    ];\n    \n    const contactElement = this.probe.findElement(contactSelectors);\n    if (contactElement) {\n      const contactText = contactElement.textContent || '';\n      \n      // Extract phone\n      const phoneMatch = contactText.match(/(\\d{3}[-.\\s]?\\d{3}[-.\\s]?\\d{4})/);\n      if (phoneMatch) {\n        dealer.phone = phoneMatch[1];\n      }\n      \n      // Extract address\n      const addressMatch = contactText.match(/([A-Za-z\\s]+),\\s*([A-Z]{2})\\s*(\\d{5})/);\n      if (addressMatch) {\n        dealer.city = addressMatch[1].trim();\n        dealer.state = addressMatch[2];\n        dealer.zip = addressMatch[3];\n      }\n    }\n  }\n\n  private async extractVIN(vehicle: Vehicle, warnings: string[]): Promise<void> {\n    // Look for VIN in labeled fields\n    const vinElement = this.probe.findByLabel(['vin', 'vehicle identification number']);\n    \n    if (vinElement) {\n      vehicle.vin = vinElement.textContent?.trim();\n    } else {\n      // Use regex on page text\n      const vinRegex = /\\b[A-HJ-NPR-Z0-9]{17}\\b/;\n      const pageText = document.body.textContent || '';\n      const vinMatch = pageText.match(vinRegex);\n      if (vinMatch) {\n        vehicle.vin = vinMatch[0];\n      } else {\n        warnings.push('VIN not found');\n      }\n    }\n  }\n\n  private async extractDescription(vehicle: Vehicle, warnings: string[]): Promise<void> {\n    const descriptionSelectors = [\n      '.vehicle-description',\n      '.description-content',\n      '.vehicle-comments',\n      '.vdp-description'\n    ];\n    \n    const descriptionElement = this.probe.findElement(descriptionSelectors);\n    if (descriptionElement) {\n      vehicle.description = descriptionElement.textContent?.trim();\n    } else {\n      warnings.push('Description not found');\n    }\n  }\n\n  private async extractPhotos(warnings: string[]): Promise<Photo[]> {\n    try {\n      return await extractPhotos([\n        '.vehicle-gallery img',\n        '.photo-gallery img',\n        '.image-gallery img',\n        '.vdp-photos img'\n      ]);\n    } catch (error) {\n      warnings.push('Failed to extract photos: ' + (error as Error).message);\n      return [];\n    }\n  }\n}\n","import { SiteAdapter, ScrapeResult, Vehicle, Dealer, Photo } from '../types';\nimport { SelectorProbe } from '../core/selectors';\nimport { normalizeVehicleData } from '../core/normalize';\nimport { extractPhotos } from '../core/photos';\nimport { Logger } from '../core/logger';\n\nexport class GenericAdapter implements SiteAdapter {\n  name = 'Generic';\n  hostnames = ['*']; // Matches any hostname\n  \n  private logger = new Logger('Generic');\n  private probe = new SelectorProbe();\n\n  isVehiclePage(url: string): boolean {\n    // Generic heuristics for vehicle pages\n    const vehicleKeywords = [\n      'vehicle', 'car', 'auto', 'inventory', 'details',\n      'listing', 'vdp', 'used-car', 'new-car'\n    ];\n    \n    return vehicleKeywords.some(keyword => \n      url.toLowerCase().includes(keyword)\n    );\n  }\n\n  async scrape(): Promise<ScrapeResult> {\n    this.logger.info('Starting generic scrape');\n    \n    const warnings: string[] = [];\n    const vehicle: Vehicle = {};\n    const dealer: Dealer = {};\n    \n    try {\n      // Try to extract data using generic approaches\n      await this.extractFromMicrodata(vehicle, warnings);\n      await this.extractFromOpenGraph(vehicle, warnings);\n      await this.extractFromStructuredData(vehicle, warnings);\n      await this.extractFromHeuristics(vehicle, dealer, warnings);\n      \n      // Extract photos using generic selectors\n      const photos = await this.extractPhotos(warnings);\n      \n      // Normalize the data\n      const normalizedVehicle = normalizeVehicleData(vehicle);\n      \n      const result: ScrapeResult = {\n        vehicle: normalizedVehicle,\n        dealer,\n        photos,\n        sourceUrl: window.location.href,\n        scrapedAt: Date.now(),\n        warnings,\n        id: `generic_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n      };\n      \n      this.logger.info('Generic scrape completed', result);\n      return result;\n      \n    } catch (error) {\n      this.logger.error('Generic scrape failed:', error);\n      throw new Error(`Generic scraping failed: ${(error as Error).message}`);\n    }\n  }\n\n  private async extractFromMicrodata(vehicle: Vehicle, _warnings: string[]): Promise<void> {\n    // Look for microdata attributes\n    const microdataElements = document.querySelectorAll('[itemtype*=\"Vehicle\"], [itemtype*=\"Car\"], [itemtype*=\"Auto\"]');\n    \n    microdataElements.forEach(element => {\n      const properties = element.querySelectorAll('[itemprop]');\n      \n      properties.forEach(prop => {\n        const propName = prop.getAttribute('itemprop');\n        const content = prop.getAttribute('content') || prop.textContent?.trim();\n        \n        if (!content) return;\n        \n        switch (propName) {\n          case 'name':\n          case 'model':\n            this.parseVehicleName(content, vehicle);\n            break;\n          case 'brand':\n          case 'manufacturer':\n            vehicle.make = content;\n            break;\n          case 'productionDate':\n          case 'modelYear':\n            vehicle.year = parseInt(content);\n            break;\n          case 'price':\n          case 'offers':\n            const priceMatch = content.match(/(\\d+)/);\n            if (priceMatch) {\n              vehicle.price = parseInt(priceMatch[1]);\n            }\n            break;\n          case 'mileageFromOdometer':\n          case 'mileage':\n            const mileageMatch = content.match(/(\\d+)/);\n            if (mileageMatch) {\n              vehicle.mileage = parseInt(mileageMatch[1]);\n            }\n            break;\n          case 'vehicleIdentificationNumber':\n          case 'vin':\n            vehicle.vin = content;\n            break;\n          case 'color':\n            if (!vehicle.exteriorColor) {\n              vehicle.exteriorColor = content;\n            }\n            break;\n          case 'description':\n            vehicle.description = content;\n            break;\n        }\n      });\n    });\n  }\n\n  private async extractFromOpenGraph(vehicle: Vehicle, _warnings: string[]): Promise<void> {\n    // Extract from Open Graph meta tags\n    const ogTags = document.querySelectorAll('meta[property^=\"og:\"]');\n    \n    ogTags.forEach(tag => {\n      const property = tag.getAttribute('property');\n      const content = tag.getAttribute('content');\n      \n      if (!content) return;\n      \n      switch (property) {\n        case 'og:title':\n          if (!vehicle.year || !vehicle.make || !vehicle.model) {\n            this.parseVehicleName(content, vehicle);\n          }\n          break;\n        case 'og:description':\n          if (!vehicle.description) {\n            vehicle.description = content;\n          }\n          break;\n      }\n    });\n    \n    // Also check Twitter cards\n    const twitterTags = document.querySelectorAll('meta[name^=\"twitter:\"]');\n    twitterTags.forEach(tag => {\n      const name = tag.getAttribute('name');\n      const content = tag.getAttribute('content');\n      \n      if (!content) return;\n      \n      if (name === 'twitter:title' && (!vehicle.year || !vehicle.make || !vehicle.model)) {\n        this.parseVehicleName(content, vehicle);\n      }\n    });\n  }\n\n  private async extractFromStructuredData(vehicle: Vehicle, _warnings: string[]): Promise<void> {\n    // Look for JSON-LD structured data\n    const jsonLdElements = document.querySelectorAll('script[type=\"application/ld+json\"]');\n    \n    jsonLdElements.forEach(script => {\n      try {\n        const data = JSON.parse(script.textContent || '');\n        \n        if (data['@type'] === 'Vehicle' || data['@type'] === 'Car') {\n          if (data.name) this.parseVehicleName(data.name, vehicle);\n          if (data.brand) vehicle.make = data.brand;\n          if (data.model) vehicle.model = data.model;\n          if (data.productionDate) vehicle.year = parseInt(data.productionDate);\n          if (data.offers && data.offers.price) {\n            const priceMatch = data.offers.price.toString().match(/(\\d+)/);\n            if (priceMatch) vehicle.price = parseInt(priceMatch[1]);\n          }\n          if (data.mileageFromOdometer) vehicle.mileage = parseInt(data.mileageFromOdometer);\n          if (data.vehicleIdentificationNumber) vehicle.vin = data.vehicleIdentificationNumber;\n          if (data.color) vehicle.exteriorColor = data.color;\n          if (data.description) vehicle.description = data.description;\n        }\n      } catch (error) {\n        // Ignore JSON parsing errors\n      }\n    });\n  }\n\n  private async extractFromHeuristics(vehicle: Vehicle, dealer: Dealer, warnings: string[]): Promise<void> {\n    // Extract using common patterns and proximity-based selection\n    \n    // Try to find title/heading with vehicle info\n    if (!vehicle.year || !vehicle.make || !vehicle.model) {\n      const headings = document.querySelectorAll('h1, h2, .title, .vehicle-title, .listing-title');\n      for (const heading of headings) {\n        const text = heading.textContent?.trim() || '';\n        if (this.looksLikeVehicleTitle(text)) {\n          this.parseVehicleName(text, vehicle);\n          break;\n        }\n      }\n    }\n    \n    // Extract price using common patterns\n    if (!vehicle.price) {\n      const priceElements = document.querySelectorAll('.price, .cost, .amount, [class*=\"price\"], [id*=\"price\"]');\n      for (const element of priceElements) {\n        const text = element.textContent || '';\n        const priceMatch = text.match(/\\$[\\d,]+/);\n        if (priceMatch) {\n          const price = parseInt(priceMatch[0].replace(/[$,]/g, ''));\n          if (price > 1000 && price < 1000000) { // Reasonable car price range\n            vehicle.price = price;\n            break;\n          }\n        }\n      }\n    }\n    \n    // Extract mileage using regex on page text\n    if (!vehicle.mileage) {\n      const pageText = document.body.textContent || '';\n      const mileageMatch = pageText.match(/(\\d{1,3}(?:,\\d{3})*)\\s*miles?/i);\n      if (mileageMatch) {\n        vehicle.mileage = parseInt(mileageMatch[1].replace(/,/g, ''));\n      }\n    }\n    \n    // Extract VIN using regex\n    if (!vehicle.vin) {\n      const pageText = document.body.textContent || '';\n      const vinMatch = pageText.match(/\\b[A-HJ-NPR-Z0-9]{17}\\b/);\n      if (vinMatch) {\n        vehicle.vin = vinMatch[0];\n      }\n    }\n    \n    // Extract dealer name from common selectors\n    if (!dealer.name) {\n      const dealerElements = document.querySelectorAll('.dealer, .dealership, .seller, [class*=\"dealer\"], [id*=\"dealer\"]');\n      for (const element of dealerElements) {\n        const text = element.textContent?.trim();\n        if (text && text.length > 3 && text.length < 100) {\n          dealer.name = text;\n          break;\n        }\n      }\n    }\n    \n    // Try to find contact info\n    const contactText = document.body.textContent || '';\n    const phoneMatch = contactText.match(/(\\d{3}[-.\\s]?\\d{3}[-.\\s]?\\d{4})/);\n    if (phoneMatch) {\n      dealer.phone = phoneMatch[1];\n    }\n    \n    // Extract specs using proximity-based selection\n    this.extractSpecsByProximity(vehicle, warnings);\n  }\n\n  private looksLikeVehicleTitle(text: string): boolean {\n    // Check if text looks like a vehicle title\n    const vehiclePattern = /\\d{4}\\s+[A-Za-z]+\\s+[A-Za-z0-9\\s]+/;\n    return vehiclePattern.test(text);\n  }\n\n  private parseVehicleName(text: string, vehicle: Vehicle): void {\n    // Parse vehicle name in format \"2023 Honda Civic LX\"\n    const match = text.match(/(\\d{4})\\s+([A-Za-z]+)\\s+([A-Za-z0-9\\s]+?)(?:\\s+([A-Za-z0-9\\s]+))?$/);\n    \n    if (match) {\n      if (!vehicle.year) vehicle.year = parseInt(match[1]);\n      if (!vehicle.make) vehicle.make = match[2];\n      \n      if (!vehicle.model) {\n        const remaining = match[3].trim();\n        const parts = remaining.split(/\\s+/);\n        vehicle.model = parts[0];\n        \n        if (parts.length > 1 && !vehicle.trim) {\n          vehicle.trim = parts.slice(1).join(' ');\n        }\n      }\n      \n      if (match[4] && !vehicle.trim) {\n        vehicle.trim = match[4];\n      }\n    }\n  }\n\n  private extractSpecsByProximity(vehicle: Vehicle, _warnings: string[]): void {\n    // Use proximity-based extraction for vehicle specs\n    const specKeywords = {\n      transmission: ['transmission', 'trans', 'automatic', 'manual', 'cvt'],\n      drivetrain: ['drivetrain', 'drive', 'awd', 'fwd', 'rwd', '4wd'],\n      engine: ['engine', 'motor', 'cylinder', 'liter', 'turbo'],\n      fuelType: ['fuel', 'gas', 'gasoline', 'diesel', 'electric', 'hybrid'],\n      exteriorColor: ['exterior color', 'color', 'paint'],\n      interiorColor: ['interior color', 'interior'],\n      bodyStyle: ['body style', 'body type', 'sedan', 'suv', 'truck', 'coupe', 'hatchback']\n    };\n    \n    Object.entries(specKeywords).forEach(([field, keywords]) => {\n      if (vehicle[field as keyof Vehicle]) return; // Already found\n      \n      for (const keyword of keywords) {\n        const element = this.probe.findByLabel([keyword]);\n        if (element) {\n          const value = element.textContent?.trim();\n          if (value && value.length > 1 && value.length < 100) {\n            (vehicle as any)[field] = value;\n            break;\n          }\n        }\n      }\n    });\n  }\n\n  private async extractPhotos(warnings: string[]): Promise<Photo[]> {\n    try {\n      // Use generic photo selectors\n      return await extractPhotos([\n        '.gallery img',\n        '.photos img',\n        '.images img',\n        '[class*=\"gallery\"] img',\n        '[class*=\"photo\"] img',\n        '[id*=\"gallery\"] img',\n        '[id*=\"photo\"] img'\n      ]);\n    } catch (error) {\n      warnings.push('Failed to extract photos: ' + (error as Error).message);\n      return [];\n    }\n  }\n}\n","import { ScrapeResult, SiteAdapter } from '../types';\nimport { AutoTraderAdapter } from '../adapters/autotrader';\nimport { CarsDotComAdapter } from '../adapters/cars_dot_com';\nimport { CarGurusAdapter } from '../adapters/cargurus';\nimport { DealerDotComAdapter } from '../adapters/dealer_dot_com';\nimport { GenericAdapter } from '../adapters/generic';\nimport { Logger } from './logger';\n\nexport class ScrapingEngine {\n  private logger = new Logger('ScrapingEngine');\n  private adapters: SiteAdapter[] = [];\n  private genericAdapter: GenericAdapter;\n\n  constructor() {\n    // Initialize all site adapters\n    this.adapters = [\n      new AutoTraderAdapter(),\n      new CarsDotComAdapter(),\n      new CarGurusAdapter(),\n      new DealerDotComAdapter()\n    ];\n    \n    this.genericAdapter = new GenericAdapter();\n    \n    this.logger.info('ScrapingEngine initialized with adapters:', \n      this.adapters.map(a => a.name));\n  }\n\n  /**\n   * Scrape the current page using the appropriate adapter\n   */\n  async scrapeCurrentPage(): Promise<ScrapeResult> {\n    const currentUrl = window.location.href;\n    const hostname = window.location.hostname;\n    \n    this.logger.info('Starting scrape for:', currentUrl);\n    \n    // Find the appropriate adapter for this site\n    const adapter = this.findAdapter(hostname, currentUrl);\n    \n    if (!adapter) {\n      throw new Error('No suitable adapter found for this site');\n    }\n    \n    this.logger.info('Using adapter:', adapter.name);\n    \n    try {\n      const result = await adapter.scrape();\n      \n      // Validate the result\n      this.validateScrapeResult(result);\n      \n      this.logger.info('Scrape completed successfully');\n      return result;\n      \n    } catch (error) {\n      this.logger.error('Scrape failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Check if the current page is a vehicle detail page\n   */\n  isVehiclePage(url: string): boolean {\n    const hostname = new URL(url).hostname;\n    const adapter = this.findAdapter(hostname, url);\n    \n    if (adapter) {\n      return adapter.isVehiclePage(url);\n    }\n    \n    // Use generic heuristics\n    return this.genericAdapter.isVehiclePage(url);\n  }\n\n  /**\n   * Get list of supported sites\n   */\n  getSupportedSites(): string[] {\n    return this.adapters.flatMap(adapter => adapter.hostnames);\n  }\n\n  /**\n   * Find the appropriate adapter for a given hostname and URL\n   */\n  private findAdapter(hostname: string, url: string): SiteAdapter | null {\n    // Try to find a specific adapter first\n    for (const adapter of this.adapters) {\n      if (this.matchesHostname(hostname, adapter.hostnames)) {\n        if (adapter.isVehiclePage(url)) {\n          return adapter;\n        }\n      }\n    }\n    \n    // Fall back to generic adapter if it looks like a vehicle page\n    if (this.genericAdapter.isVehiclePage(url)) {\n      return this.genericAdapter;\n    }\n    \n    return null;\n  }\n\n  /**\n   * Check if hostname matches any of the adapter hostnames\n   */\n  private matchesHostname(hostname: string, adapterHostnames: string[]): boolean {\n    return adapterHostnames.some(adapterHostname => {\n      if (adapterHostname === '*') return true;\n      \n      // Remove www. prefix for comparison\n      const cleanHostname = hostname.replace(/^www\\./, '');\n      const cleanAdapterHostname = adapterHostname.replace(/^www\\./, '');\n      \n      return cleanHostname === cleanAdapterHostname || \n             cleanHostname.endsWith('.' + cleanAdapterHostname);\n    });\n  }\n\n  /**\n   * Validate scrape result and add warnings for missing data\n   */\n  private validateScrapeResult(result: ScrapeResult): void {\n    const { vehicle } = result;\n    \n    // Required vehicle fields\n    const requiredFields = ['year', 'make', 'model', 'price'];\n    const missingFields: string[] = [];\n    \n    requiredFields.forEach(field => {\n      if (!vehicle[field as keyof typeof vehicle]) {\n        missingFields.push(field);\n      }\n    });\n    \n    if (missingFields.length > 0) {\n      result.warnings.push(`Missing required fields: ${missingFields.join(', ')}`);\n    }\n    \n    // Validate VIN format if present\n    if (vehicle.vin) {\n      const vinRegex = /^[A-HJ-NPR-Z0-9]{17}$/;\n      if (!vinRegex.test(vehicle.vin)) {\n        result.warnings.push('VIN format appears invalid');\n      }\n    }\n    \n    // Validate year range\n    if (vehicle.year) {\n      const currentYear = new Date().getFullYear();\n      if (vehicle.year < 1950 || vehicle.year > currentYear + 1) {\n        result.warnings.push('Vehicle year appears out of range');\n      }\n    }\n    \n    // Validate price range\n    if (vehicle.price) {\n      if (vehicle.price < 100 || vehicle.price > 1000000) {\n        result.warnings.push('Price appears out of normal range');\n      }\n    }\n    \n    // Validate mileage\n    if (vehicle.mileage) {\n      if (vehicle.mileage < 0 || vehicle.mileage > 1000000) {\n        result.warnings.push('Mileage appears out of normal range');\n      }\n    }\n    \n    // Check for photos\n    if (result.photos.length === 0) {\n      result.warnings.push('No photos found');\n    }\n    \n    this.logger.debug('Validation completed. Warnings:', result.warnings);\n  }\n}\n","import { ScrapeResult, FacebookAutofillOptions } from '../types';\nimport { generateFacebookTitle, generateFacebookDescription } from './normalize';\nimport { urlsToFiles } from './photos';\nimport { Logger } from './logger';\n\nexport class FacebookAutofiller {\n  private logger = new Logger('FacebookAutofiller');\n  // Future use for retry logic\n  // private readonly maxRetries = 5;\n  // private readonly retryDelay = 2000;\n\n  /**\n   * Auto-fill Facebook Marketplace vehicle listing form\n   */\n  async autofillForm(scrapeResult: ScrapeResult, options: FacebookAutofillOptions = {}): Promise<void> {\n    this.logger.info('Starting Facebook Marketplace autofill');\n    \n    const { vehicle, dealer, photos } = scrapeResult;\n    const opts = {\n      condition: 'Used' as const,\n      uploadPhotos: true,\n      maxPhotos: 20,\n      ...options\n    };\n\n    try {\n      // Wait for the page to be ready\n      await this.waitForPageReady();\n\n      // Fill basic vehicle information\n      await this.fillVehicleDetails(vehicle, opts);\n      \n      // Fill location information\n      await this.fillLocationInfo(dealer);\n      \n      // Fill description\n      await this.fillDescription(vehicle, dealer, scrapeResult.vehicle.stockNumber);\n      \n      // Upload photos if enabled\n      if (opts.uploadPhotos && photos.length > 0) {\n        await this.uploadPhotos(photos, opts.maxPhotos);\n      }\n\n      this.logger.info('Facebook autofill completed successfully');\n      \n    } catch (error) {\n      this.logger.error('Facebook autofill failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Wait for Facebook Marketplace form to be ready\n   */\n  private async waitForPageReady(): Promise<void> {\n    this.logger.debug('Waiting for Facebook page to be ready');\n    \n    // Wait for the main form container\n    const formSelector = '[data-testid=\"marketplace_composer_form\"], .marketplace-composer, form[data-testid*=\"composer\"]';\n    await this.waitForSelector(formSelector, 10000);\n    \n    // Additional wait for form fields to be rendered\n    await this.sleep(2000);\n    \n    this.logger.debug('Facebook page is ready');\n  }\n\n  /**\n   * Fill vehicle details in the form\n   */\n  private async fillVehicleDetails(vehicle: any, options: FacebookAutofillOptions): Promise<void> {\n    this.logger.debug('Filling vehicle details');\n\n    // Fill title\n    const title = generateFacebookTitle(vehicle);\n    await this.fillInput(['[data-testid=\"marketplace_composer_title\"]', 'input[placeholder*=\"title\" i]', 'input[name=\"title\"]'], title);\n\n    // Fill price\n    if (vehicle.price) {\n      await this.fillInput([\n        '[data-testid=\"marketplace_composer_price\"]',\n        'input[placeholder*=\"price\" i]',\n        'input[name=\"price\"]',\n        'input[type=\"number\"]'\n      ], vehicle.price.toString());\n    }\n\n    // Fill year\n    if (vehicle.year) {\n      await this.fillSelect(['select[data-testid*=\"year\"]', 'select[name*=\"year\"]'], vehicle.year.toString());\n    }\n\n    // Fill make\n    if (vehicle.make) {\n      await this.fillSelect(['select[data-testid*=\"make\"]', 'select[name*=\"make\"]'], vehicle.make);\n    }\n\n    // Fill model\n    if (vehicle.model) {\n      await this.fillSelect(['select[data-testid*=\"model\"]', 'select[name*=\"model\"]'], vehicle.model);\n    }\n\n    // Fill mileage\n    if (vehicle.mileage) {\n      await this.fillInput([\n        '[data-testid*=\"mileage\"]',\n        'input[placeholder*=\"mileage\" i]',\n        'input[name*=\"mileage\"]'\n      ], vehicle.mileage.toString());\n    }\n\n    // Fill VIN\n    if (vehicle.vin) {\n      await this.fillInput([\n        '[data-testid*=\"vin\"]',\n        'input[placeholder*=\"vin\" i]',\n        'input[name*=\"vin\"]'\n      ], vehicle.vin);\n    }\n\n    // Fill condition\n    const condition = options.condition || vehicle.condition || 'Used';\n    await this.fillSelect([\n      'select[data-testid*=\"condition\"]',\n      'select[name*=\"condition\"]'\n    ], condition);\n\n    // Fill transmission\n    if (vehicle.transmission) {\n      await this.fillSelect([\n        'select[data-testid*=\"transmission\"]',\n        'select[name*=\"transmission\"]'\n      ], vehicle.transmission);\n    }\n\n    // Fill drivetrain\n    if (vehicle.drivetrain) {\n      await this.fillSelect([\n        'select[data-testid*=\"drivetrain\"]',\n        'select[name*=\"drivetrain\"]',\n        'select[data-testid*=\"drive\"]'\n      ], vehicle.drivetrain);\n    }\n\n    // Fill fuel type\n    if (vehicle.fuelType) {\n      await this.fillSelect([\n        'select[data-testid*=\"fuel\"]',\n        'select[name*=\"fuel\"]'\n      ], vehicle.fuelType);\n    }\n\n    // Fill body style\n    if (vehicle.bodyStyle) {\n      await this.fillSelect([\n        'select[data-testid*=\"body\"]',\n        'select[name*=\"body\"]',\n        'select[data-testid*=\"type\"]'\n      ], vehicle.bodyStyle);\n    }\n\n    // Fill exterior color\n    if (vehicle.exteriorColor) {\n      await this.fillSelect([\n        'select[data-testid*=\"exterior\"]',\n        'select[data-testid*=\"color\"]',\n        'select[name*=\"color\"]'\n      ], vehicle.exteriorColor);\n    }\n\n    this.logger.debug('Vehicle details filled');\n  }\n\n  /**\n   * Fill location information\n   */\n  private async fillLocationInfo(dealer: any): Promise<void> {\n    if (!dealer.city && !dealer.state && !dealer.zip) {\n      return;\n    }\n\n    this.logger.debug('Filling location info');\n\n    // Try to fill location fields\n    const locationText = [dealer.city, dealer.state, dealer.zip].filter(Boolean).join(', ');\n    \n    await this.fillInput([\n      '[data-testid*=\"location\"]',\n      'input[placeholder*=\"location\" i]',\n      'input[placeholder*=\"city\" i]',\n      'input[name*=\"location\"]',\n      'input[name*=\"city\"]'\n    ], locationText);\n\n    this.logger.debug('Location info filled');\n  }\n\n  /**\n   * Fill description field\n   */\n  private async fillDescription(vehicle: any, dealer: any, stockNumber?: string): Promise<void> {\n    this.logger.debug('Filling description');\n\n    const description = generateFacebookDescription(vehicle, dealer, stockNumber);\n\n    await this.fillTextarea([\n      '[data-testid*=\"description\"]',\n      'textarea[placeholder*=\"description\" i]',\n      'textarea[name*=\"description\"]',\n      'textarea'\n    ], description);\n\n    this.logger.debug('Description filled');\n  }\n\n  /**\n   * Upload photos to Facebook Marketplace\n   */\n  private async uploadPhotos(photos: any[], maxPhotos: number): Promise<void> {\n    this.logger.info(`Starting photo upload (${Math.min(photos.length, maxPhotos)} photos)`);\n\n    try {\n      // Convert URLs to File objects\n      const photosToUpload = photos.slice(0, maxPhotos);\n      const files = await urlsToFiles(photosToUpload);\n\n      if (files.length === 0) {\n        this.logger.warn('No files could be converted for upload');\n        return;\n      }\n\n      // Find file input\n      const fileInput = await this.waitForSelector([\n        'input[type=\"file\"]',\n        '[data-testid*=\"photo\"] input[type=\"file\"]',\n        '[data-testid*=\"image\"] input[type=\"file\"]'\n      ]) as HTMLInputElement;\n\n      if (!fileInput) {\n        throw new Error('Could not find file input for photo upload');\n      }\n\n      // Create DataTransfer object with files\n      const dataTransfer = new DataTransfer();\n      files.forEach(file => {\n        dataTransfer.items.add(file);\n      });\n\n      // Set files to input\n      fileInput.files = dataTransfer.files;\n\n      // Trigger change event\n      const changeEvent = new Event('change', { bubbles: true });\n      fileInput.dispatchEvent(changeEvent);\n\n      // Also trigger input event for React forms\n      const inputEvent = new Event('input', { bubbles: true });\n      fileInput.dispatchEvent(inputEvent);\n\n      this.logger.info(`Uploaded ${files.length} photos successfully`);\n\n    } catch (error) {\n      this.logger.error('Photo upload failed:', error);\n      \n      // Fallback: Show instruction to user\n      this.showPhotoUploadInstructions(photos.length);\n    }\n  }\n\n  /**\n   * Show instructions for manual photo upload\n   */\n  private showPhotoUploadInstructions(photoCount: number): void {\n    const message = `Automatic photo upload failed. Please manually upload the ${photoCount} vehicle photos that have been downloaded to your Downloads folder.`;\n    \n    // Try to show a native notification\n    if ('Notification' in window && Notification.permission === 'granted') {\n      new Notification('Photo Upload Required', {\n        body: message,\n        icon: chrome.runtime.getURL('public/icons/icon48.png')\n      });\n    } else {\n      // Fallback to alert\n      alert(message);\n    }\n  }\n\n  /**\n   * Fill an input field using multiple selectors\n   */\n  private async fillInput(selectors: string[], value: string): Promise<void> {\n    const input = await this.waitForSelector(selectors, 5000) as HTMLInputElement;\n    \n    if (input) {\n      // Clear existing value\n      input.value = '';\n      input.focus();\n      \n      // Set new value\n      input.value = value;\n      \n      // Trigger events\n      input.dispatchEvent(new Event('input', { bubbles: true }));\n      input.dispatchEvent(new Event('change', { bubbles: true }));\n      input.dispatchEvent(new Event('blur', { bubbles: true }));\n      \n      this.logger.debug(`Filled input with value: ${value}`);\n    } else {\n      this.logger.warn(`Could not find input with selectors: ${selectors.join(', ')}`);\n    }\n  }\n\n  /**\n   * Fill a textarea field using multiple selectors\n   */\n  private async fillTextarea(selectors: string[], value: string): Promise<void> {\n    const textarea = await this.waitForSelector(selectors, 5000) as HTMLTextAreaElement;\n    \n    if (textarea) {\n      textarea.value = '';\n      textarea.focus();\n      textarea.value = value;\n      \n      textarea.dispatchEvent(new Event('input', { bubbles: true }));\n      textarea.dispatchEvent(new Event('change', { bubbles: true }));\n      textarea.dispatchEvent(new Event('blur', { bubbles: true }));\n      \n      this.logger.debug(`Filled textarea with ${value.length} characters`);\n    } else {\n      this.logger.warn(`Could not find textarea with selectors: ${selectors.join(', ')}`);\n    }\n  }\n\n  /**\n   * Fill a select field using multiple selectors\n   */\n  private async fillSelect(selectors: string[], value: string): Promise<void> {\n    const select = await this.waitForSelector(selectors, 5000) as HTMLSelectElement;\n    \n    if (select) {\n      // Try exact match first\n      const exactOption = Array.from(select.options).find(option => \n        option.value === value || option.textContent?.trim() === value\n      );\n\n      if (exactOption) {\n        select.value = exactOption.value;\n      } else {\n        // Try partial match\n        const partialOption = Array.from(select.options).find(option => \n          option.textContent?.toLowerCase().includes(value.toLowerCase()) ||\n          option.value.toLowerCase().includes(value.toLowerCase())\n        );\n\n        if (partialOption) {\n          select.value = partialOption.value;\n        } else {\n          this.logger.warn(`Could not find option \"${value}\" in select`);\n          return;\n        }\n      }\n\n      select.dispatchEvent(new Event('change', { bubbles: true }));\n      this.logger.debug(`Selected option: ${value}`);\n    } else {\n      this.logger.warn(`Could not find select with selectors: ${selectors.join(', ')}`);\n    }\n  }\n\n  /**\n   * Wait for an element to appear using multiple selectors\n   */\n  private async waitForSelector(selectors: string | string[], timeout = 10000): Promise<Element | null> {\n    const selectorArray = Array.isArray(selectors) ? selectors : [selectors];\n    const startTime = Date.now();\n\n    while (Date.now() - startTime < timeout) {\n      for (const selector of selectorArray) {\n        const element = document.querySelector(selector);\n        if (element) {\n          return element;\n        }\n      }\n      \n      await this.sleep(100);\n    }\n\n    this.logger.warn(`Timeout waiting for selectors: ${selectorArray.join(', ')}`);\n    return null;\n  }\n\n  /**\n   * Sleep for specified milliseconds\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n","import { ScrapeResult } from './types';\nimport { ScrapingEngine } from './core/scrape';\nimport { Logger } from './core/logger';\nimport { FacebookAutofiller } from './core/facebook';\n\nconst logger = new Logger('Content');\nlet scrapingEngine: ScrapingEngine;\nlet facebookAutofiller: FacebookAutofiller | null = null;\n\n// Initialize based on the current site\nfunction initialize() {\n  const hostname = window.location.hostname;\n  logger.info('Initializing content script on:', hostname);\n  \n  if (hostname.includes('facebook.com')) {\n    // Initialize Facebook autofiller\n    facebookAutofiller = new FacebookAutofiller();\n    initializeFacebookAutofill();\n  } else {\n    // Initialize scraping engine for vehicle sites\n    scrapingEngine = new ScrapingEngine();\n    initializeVehicleScraping();\n  }\n}\n\nfunction initializeVehicleScraping() {\n  // Add scraping functionality to window object for background script access\n  (window as any).vehicleScraper = {\n    scrape: async (): Promise<ScrapeResult | null> => {\n      try {\n        return await scrapingEngine.scrapeCurrentPage();\n      } catch (error) {\n        logger.error('Scraping failed:', error);\n        return null;\n      }\n    }\n  };\n  \n  // Add visual indicator that the page is scrapable\n  addScrapeIndicator();\n}\n\nfunction initializeFacebookAutofill() {\n  // Check if we have autofill data\n  const autofillData = (window as any).vehicleAutofillData;\n  \n  if (autofillData && facebookAutofiller) {\n    logger.info('Starting Facebook autofill with data:', autofillData);\n    \n    // Wait for the page to be ready\n    setTimeout(() => {\n      facebookAutofiller!.autofillForm(autofillData).catch(error => {\n        logger.error('Autofill failed:', error);\n      });\n    }, 3000);\n  }\n  \n  // Listen for autofill data from background script\n  window.addEventListener('message', (event) => {\n    if (event.data.type === 'AUTOFILL_VEHICLE_DATA' && facebookAutofiller) {\n      facebookAutofiller.autofillForm(event.data.scrapeResult).catch(error => {\n        logger.error('Autofill failed:', error);\n      });\n    }\n  });\n}\n\nfunction addScrapeIndicator() {\n  // Check if this looks like a vehicle detail page\n  const isVehiclePage = scrapingEngine.isVehiclePage(window.location.href);\n  \n  if (!isVehiclePage) {\n    return;\n  }\n  \n  // Create a small floating indicator\n  const indicator = document.createElement('div');\n  indicator.id = 'vehicle-scraper-indicator';\n  indicator.style.cssText = `\n    position: fixed;\n    top: 20px;\n    right: 20px;\n    background: #1877f2;\n    color: white;\n    padding: 8px 12px;\n    border-radius: 6px;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;\n    font-size: 12px;\n    font-weight: 500;\n    z-index: 10000;\n    box-shadow: 0 2px 8px rgba(0,0,0,0.15);\n    cursor: pointer;\n    transition: all 0.2s ease;\n  `;\n  indicator.textContent = ' Scrapable';\n  \n  indicator.addEventListener('mouseenter', () => {\n    indicator.style.transform = 'scale(1.05)';\n  });\n  \n  indicator.addEventListener('mouseleave', () => {\n    indicator.style.transform = 'scale(1)';\n  });\n  \n  indicator.addEventListener('click', () => {\n    // Open the extension popup programmatically (if possible) or show a message\n    chrome.runtime.sendMessage({ type: 'OPEN_POPUP' });\n  });\n  \n  document.body.appendChild(indicator);\n  \n  // Auto-hide after 5 seconds\n  setTimeout(() => {\n    if (indicator.parentNode) {\n      indicator.style.opacity = '0.3';\n    }\n  }, 5000);\n}\n\n// Listen for messages from background script\nchrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {\n  logger.debug('Content script received message:', message);\n  \n  switch (message.type) {\n    case 'PAGE_LOADED':\n      // Page finished loading, ensure initialization\n      if (!scrapingEngine && !facebookAutofiller) {\n        initialize();\n      }\n      return false;\n      \n    case 'SCRAPE_NOW':\n      if (scrapingEngine) {\n        scrapingEngine.scrapeCurrentPage()\n          .then(result => sendResponse({ success: true, result }))\n          .catch(error => sendResponse({ error: error.message }));\n        return true; // Keep message channel open\n      }\n      return false;\n      \n    case 'AUTOFILL_FACEBOOK':\n      if (facebookAutofiller) {\n        facebookAutofiller.autofillForm(message.scrapeResult)\n          .then(() => sendResponse({ success: true }))\n          .catch(error => sendResponse({ error: error.message }));\n        return true; // Keep message channel open\n      }\n      return false;\n      \n    default:\n      return false;\n  }\n});\n\n// Initialize when the script loads\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', initialize);\n} else {\n  initialize();\n}\n\n// Also initialize when navigation happens (SPA sites)\nlet lastUrl = window.location.href;\nnew MutationObserver(() => {\n  const currentUrl = window.location.href;\n  if (currentUrl !== lastUrl) {\n    lastUrl = currentUrl;\n    setTimeout(initialize, 1000); // Give SPA time to render\n  }\n}).observe(document, { subtree: true, childList: true });\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t854: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkworkspace\"] = self[\"webpackChunkworkspace\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [76], () => (__webpack_require__(620)))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["deferred","SelectorProbe","logger","findElement","selectors","selector","element","document","querySelector","this","debug","error","warn","join","findElements","elements","found","querySelectorAll","push","Array","from","unique","Set","length","findByLabel","labels","container","searchContainer","label","labelElement","findLabelElement","associated","getAssociatedElement","proximityElement","findByProximity","searchText","searchLower","toLowerCase","textNodes","findTextNodes","textNode","parentElement","nearbyElements","findNearbyFormElements","isRelevantFormElement","findByAria","ariaLabels","waitForElement","timeout","startTime","Date","now","Promise","resolve","setTimeout","isVisible","rect","getBoundingClientRect","style","getComputedStyle","width","height","visibility","display","opacity","getElementInfo","tagName","id","className","textContent","slice","visible","position","x","y","labelText","text","dataLabel","getAttribute","includes","forAttribute","getElementById","nested","sibling","nextElementSibling","walker","createTreeWalker","NodeFilter","SHOW_TEXT","acceptNode","node","FILTER_ACCEPT","FILTER_REJECT","nextNode","formElements","parent","level","children","previousElementSibling","inputType","type","async","extractPhotos","info","photos","seenUrls","imageElements","forEach","el","HTMLImageElement","add","size","img","photoUrls","extractImageUrls","url","cleanUrl","cleanImageUrl","makeAbsoluteUrl","has","isValidImageUrl","photo","naturalWidth","undefined","naturalHeight","isMain","isMainImage","sort","a","b","aSize","urls","src","srcset","srcsetUrls","sources","split","map","s","trim","parsed","source","parts","descriptor","endsWith","parseInt","density","parseFloat","Math","round","p","parseSrcset","attr","value","body","bgImage","backgroundImage","match","startsWith","window","location","protocol","origin","currentPath","pathname","replace","urlObj","URL","param","searchParams","delete","hash","toString","some","ext","indicator","mainImageIndicators","depth","parentClass","parentId","AutoTraderAdapter","name","hostnames","probe","isVehiclePage","test","scrape","warnings","vehicle","dealer","extractTitleInfo","extractPriceAndMileage","extractSpecs","extractDealerInfo","extractVIN","extractDescription","result","normalize","sourceUrl","href","scrapedAt","random","substr","Error","message","titleElement","titleText","titleMatch","year","make","model","priceElement","priceMatch","price","mileageElement","mileageMatch","mileage","mileageRegex","_warnings","specsSection","item","transmission","extractSpecValue","drivetrain","engine","fuelType","exteriorColor","interiorColor","bodyStyle","transmissionEl","colorEl","fullText","specType","regex","RegExp","dealerNameElement","contactElement","contactText","phoneMatch","phone","addressMatch","city","state","zip","vinElement","vin","vinRegex","vinMatch","descriptionElement","description","CarsDotComAdapter","specItems","currentLabel","_index","parseSpecField","dataAttributes","vinDataElement","CarGurusAdapter","vinLabelElement","DealerDotComAdapter","specTable","row","cells","GenericAdapter","keyword","extractFromMicrodata","extractFromOpenGraph","extractFromStructuredData","extractFromHeuristics","prop","propName","content","parseVehicleName","tag","property","script","data","JSON","parse","brand","productionDate","offers","mileageFromOdometer","vehicleIdentificationNumber","color","headings","heading","looksLikeVehicleTitle","priceElements","dealerElements","extractSpecsByProximity","Object","entries","field","keywords","ScrapingEngine","constructor","adapters","genericAdapter","scrapeCurrentPage","currentUrl","hostname","adapter","findAdapter","validateScrapeResult","getSupportedSites","flatMap","matchesHostname","adapterHostnames","adapterHostname","cleanHostname","cleanAdapterHostname","missingFields","currentYear","getFullYear","FacebookAutofiller","autofillForm","scrapeResult","options","opts","condition","uploadPhotos","maxPhotos","waitForPageReady","fillVehicleDetails","fillLocationInfo","fillDescription","stockNumber","waitForSelector","sleep","title","fillInput","fillSelect","locationText","filter","Boolean","fillTextarea","min","photosToUpload","files","i","response","fetch","ok","status","blob","extension","contentType","headers","get","filename","file","File","urlsToFiles","fileInput","dataTransfer","DataTransfer","items","changeEvent","Event","bubbles","dispatchEvent","inputEvent","showPhotoUploadInstructions","photoCount","Notification","permission","icon","chrome","runtime","getURL","alert","input","focus","textarea","select","exactOption","find","option","partialOption","selectorArray","isArray","ms","scrapingEngine","facebookAutofiller","initialize","autofillData","vehicleAutofillData","catch","addEventListener","event","initializeFacebookAutofill","vehicleScraper","createElement","cssText","transform","sendMessage","appendChild","parentNode","addScrapeIndicator","onMessage","addListener","_sender","sendResponse","then","success","readyState","lastUrl","MutationObserver","observe","subtree","childList","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","O","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","keys","every","key","splice","r","d","definition","o","defineProperty","enumerable","obj","prototype","hasOwnProperty","call","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","chunkLoadingGlobal","self","bind","__webpack_exports__"],"sourceRoot":""}