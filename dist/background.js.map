{"version":3,"file":"background.js","mappings":"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","sources":["webpack://workspace/webpack/runtime/chunk loaded","webpack://workspace/./src/background.ts","webpack://workspace/webpack/bootstrap","webpack://workspace/webpack/runtime/define property getters","webpack://workspace/webpack/runtime/hasOwnProperty shorthand","webpack://workspace/webpack/runtime/jsonp chunk loading","webpack://workspace/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","import { ScrapeResult, StorageData } from './types';\nimport { Logger } from './core/logger';\n\nconst logger = new Logger('Background');\n\n// Handle extension installation\nchrome.runtime.onInstalled.addListener(() => {\n  logger.info('Extension installed');\n  \n  // Initialize storage with default settings\n  const defaultData: StorageData = {\n    scrapeResults: [],\n    settings: {\n      autofillOptions: {\n        condition: 'Used',\n        uploadPhotos: true,\n        maxPhotos: 20\n      },\n      enabledSites: ['autotrader.com', 'cars.com', 'cargurus.com', 'dealer.com']\n    }\n  };\n  \n  chrome.storage.local.set(defaultData).catch(err => {\n    logger.error('Failed to initialize storage:', err);\n  });\n});\n\n// Handle messages from content scripts and popup\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n  logger.debug('Received message:', message);\n  \n  switch (message.type) {\n    case 'SCRAPE_PAGE':\n      handleScrapeRequest(sender.tab?.id, sendResponse);\n      return true; // Keep message channel open for async response\n      \n    case 'DOWNLOAD_PHOTOS':\n      handlePhotoDownload(message.photos, sendResponse);\n      return true;\n      \n    case 'OPEN_FACEBOOK_MARKETPLACE':\n      handleFacebookOpen(message.scrapeResult, sendResponse);\n      return true;\n      \n    default:\n      logger.warn('Unknown message type:', message.type);\n      return false;\n  }\n});\n\nasync function handleScrapeRequest(tabId: number | undefined, sendResponse: (response: any) => void) {\n  if (!tabId) {\n    sendResponse({ error: 'No active tab' });\n    return;\n  }\n  \n  try {\n    // Inject scraping script into the current tab\n    const results = await chrome.scripting.executeScript({\n      target: { tabId },\n      func: () => {\n        // This will be replaced by the actual scraping logic\n        return (window as any).vehicleScraper?.scrape();\n      }\n    });\n    \n    const scrapeResult = results[0]?.result;\n    \n    if (scrapeResult) {\n      // Store the result\n      await saveScrapeResult(scrapeResult);\n      sendResponse({ success: true, result: scrapeResult });\n    } else {\n      sendResponse({ error: 'No data scraped from this page' });\n    }\n  } catch (error) {\n    logger.error('Scrape request failed:', error);\n    sendResponse({ error: 'Failed to scrape page: ' + (error as Error).message });\n  }\n}\n\nasync function handlePhotoDownload(photos: string[], sendResponse: (response: any) => void) {\n  try {\n    const downloadPromises = photos.map((url, index) => {\n      const filename = `vehicle_photo_${index + 1}.jpg`;\n      return chrome.downloads.download({\n        url,\n        filename: `vehicle_photos/${filename}`,\n        saveAs: false\n      });\n    });\n    \n    await Promise.all(downloadPromises);\n    sendResponse({ success: true, count: photos.length });\n  } catch (error) {\n    logger.error('Photo download failed:', error);\n    sendResponse({ error: 'Failed to download photos: ' + (error as Error).message });\n  }\n}\n\nasync function handleFacebookOpen(scrapeResult: ScrapeResult, sendResponse: (response: any) => void) {\n  try {\n    // Open Facebook Marketplace create listing page\n    const fbUrl = 'https://www.facebook.com/marketplace/create/vehicle';\n    \n    const tab = await chrome.tabs.create({ url: fbUrl });\n    \n    // Wait a moment for the page to load, then inject autofill script\n    setTimeout(async () => {\n      if (tab.id) {\n        try {\n          await chrome.scripting.executeScript({\n            target: { tabId: tab.id },\n            func: (data) => {\n              // Store the scrape result for the Facebook content script to use\n              (window as any).vehicleAutofillData = data;\n            },\n            args: [scrapeResult]\n          });\n          \n          sendResponse({ success: true, tabId: tab.id });\n        } catch (error) {\n          logger.error('Failed to inject autofill data:', error);\n          sendResponse({ error: 'Failed to prepare autofill data' });\n        }\n      }\n    }, 2000);\n    \n  } catch (error) {\n    logger.error('Facebook open failed:', error);\n    sendResponse({ error: 'Failed to open Facebook Marketplace: ' + (error as Error).message });\n  }\n}\n\nasync function saveScrapeResult(result: ScrapeResult): Promise<void> {\n  try {\n    const data = await chrome.storage.local.get('scrapeResults');\n    const scrapeResults: ScrapeResult[] = data.scrapeResults || [];\n    \n    // Add new result to the beginning and limit to 50\n    scrapeResults.unshift(result);\n    if (scrapeResults.length > 50) {\n      scrapeResults.splice(50);\n    }\n    \n    await chrome.storage.local.set({ scrapeResults });\n    logger.info('Saved scrape result:', result.id);\n  } catch (error) {\n    logger.error('Failed to save scrape result:', error);\n  }\n}\n\n// Handle tab updates to inject content scripts on supported sites\nchrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n  if (changeInfo.status === 'complete' && tab.url) {\n    const supportedSites = [\n      'autotrader.com',\n      'cars.com',\n      'cargurus.com',\n      'dealer.com'\n    ];\n    \n    const isSupported = supportedSites.some(site => tab.url!.includes(site));\n    \n    if (isSupported) {\n      // Content script should already be injected via manifest, but we can notify it\n      chrome.tabs.sendMessage(tabId, { type: 'PAGE_LOADED' }).catch(() => {\n        // Ignore errors if content script isn't ready yet\n      });\n    }\n  }\n});\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t471: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkworkspace\"] = self[\"webpackChunkworkspace\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [76], () => (__webpack_require__(825)))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["deferred","logger","chrome","runtime","onInstalled","addListener","info","storage","local","set","scrapeResults","settings","autofillOptions","condition","uploadPhotos","maxPhotos","enabledSites","catch","err","error","onMessage","message","sender","sendResponse","debug","type","async","tabId","results","scripting","executeScript","target","func","window","vehicleScraper","scrape","scrapeResult","result","get","unshift","length","splice","id","saveScrapeResult","success","handleScrapeRequest","tab","photos","downloadPromises","map","url","index","filename","downloads","download","saveAs","Promise","all","count","handlePhotoDownload","fbUrl","tabs","create","setTimeout","data","vehicleAutofillData","args","handleFacebookOpen","warn","onUpdated","changeInfo","status","some","site","includes","sendMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","m","O","chunkIds","fn","priority","notFulfilled","Infinity","i","fulfilled","j","Object","keys","every","key","r","d","definition","o","defineProperty","enumerable","obj","prop","prototype","hasOwnProperty","call","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","chunkLoadingGlobal","self","forEach","bind","push","__webpack_exports__"],"sourceRoot":""}